{"meta":{"title":"Born To Do","subtitle":null,"description":"There is nothing you can complain about, it all depends on human effort.","author":"Charlie","url":"http://lichaoyu.com"},"pages":[],"posts":[{"title":"lcy","slug":"lcy","date":"2018-06-20T06:15:46.000Z","updated":"2018-06-20T06:15:46.494Z","comments":true,"path":"2018/06/20/lcy/","link":"","permalink":"http://lichaoyu.com/2018/06/20/lcy/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android推送分析","slug":"2018-06-19_Android推送分析","date":"2018-06-19T03:23:16.000Z","updated":"2018-06-20T06:27:50.187Z","comments":true,"path":"2018/06/19/2018-06-19_Android推送分析/","link":"","permalink":"http://lichaoyu.com/2018/06/19/2018-06-19_Android推送分析/","excerpt":"","text":"一些基本概念阻塞指执行设备操作时，不能获得资源则挂起进程，被挂起的进程进入休眠，从调度器的进行队列中移走。 非阻塞指在不能获得资源的情况下，要么放弃，要么不停地查询，直到可以操作。 C/S通讯思路实现客户端和服务器端实时通讯，有两种思路： 定时去server查询数据，通常是通过HTTP协议来访问web服务器，称为Polling(轮询)； 移动端和服务器建立长连接，使用XMPP长连接，称为Push(推送)。 Push在Android平台上长连接的实现 既然我们知道我们移动端要和Internet进行通信，必须通过运营商的网关，所以，为了不让NAT映射表失效，我们需要定时向Internet发送数据，因为只是为了不然NAT映射表失效，所以只需发送长度为0的数据即可。注意这种定时发送的时间又叫心跳时间。 Timer:可以按照计划或者时间周期来执行相关的任务。但是Timer需要用WakeLock来让CPU保持唤醒状态，才能保证任务的执行，这样子会消耗大量流量；当CPU处于休眠的时候，就不能唤醒执行任务，所以应用于移动端明显是不合适。 AlarmManager：AlarmManager类是属于android系统封装好来管理RTC模块的管理类。这里就涉及到RTC模块，要更好地了解两者的区别，就要明白两者真正的区别。RTC（Real- Time Clock）实时闹钟在一个嵌入式系统中，通常采用RTC 来提供可靠的系统时间，包括时分秒和年月日等;而且要求在系统处于关机状态下它也能够正常工作（通常采用后备电池供电），它的外围也不需要太多的辅助电路，典型的就是只需要一个高精度的32.768KHz 晶体和电阻电容等。（如果对这方面感兴趣，可以自己查阅相关资料，这里就说个大概）好了，回来正题。所以，AlarmManager又称全局定时闹钟。这意味着，当我用使用AlarmManager来定时执行任务，CPU可以正常地休眠，只有在执行任务是，才唤醒CPU，这个过程是很短时间的。 实现全局定时功能： 1234//获得闹钟管理器 AlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);//设置任务执行计划 //从firstTime才开始执行，每隔5秒再执行am.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, firstTime, 5*1000, sender); 总结：在android客户端使用Push推送时，应该使用AlarmManager全局定时来实现心跳功能，使其真正实现长连接。 服务器端实现当有大量的手机终端需要与服务器维持长连接时，对服务器的设计会是一个很大的挑战。 假设一台服务器维护10万个长连接，当有1000万用户量时，需要有多达100台的服务器来维护这些用户的长连接，这里还不算用于做备份的服务器，这将会是一个巨大的成本问题。那就需要我们尽可能提高单台服务器接入用户的量，也就是业界已经讨论很久了的 C10K 问题。 这是他们怎么做的了，他们是非常巧妙的利用cpu中多核的原理，利用多核来唤起了相应核数个线程了，并且利用非阻塞的消息队列的机制，大大提高了服务器的吞吐量了，这样能够是一个服务器维持200个左右的长连接了，这样有效突破了业界一个瓶颈了。可见多核实现了android消息推送重要性。相应的思维导图如下： 实时通讯方式示例图 痛难点及解决方案做推送需要解决的最大三个问题：电量消耗，数据流量消耗，服务持久化。 电量消耗优化与数据流量消耗优化： 这两个问题其实可以合并成一个问题，因为请求服务器其实也是一个费电的事情。与维持一个长连接类似，要实现推送功能，不管是维持一个长连接或者是定时请求服务器都需要耗费网络数据流量，而只不过长连接是一个细水长流不断耗费，而轮询是一次一大断数据的耗费。这样就需要一种可行的策略去配置，让轮询按照我们想要的方式去执行。目前我采用的思路是当手机处于GPRS模式时降低轮询的频率，每5分钟请求一次服务器，当手机处于WiFi模式时每2分钟请求一次服务器，同时设置如果熄灭屏幕则停止推送请求，当屏幕熄灭20秒后杀死推送进程，这样不仅不需要考虑维护一个进程的消耗同时也节省了数据流量的使用。 服务持久化： 服务持久化就是进程常驻，说白了就是进程保活。要尽可能使我们的进程保持较高的优先级，不轻易被系统杀死。像QQ微信这种应用做的就非常好，不管使用第三方手机助手或者使用系统停止一个应用(不是设置里面的那种停止，是长按Home键的那种)，后台Service都不会被回收。 在Android的ActivityManager中有一个内部类RunningAppProcessInfo，用来记录当前系统中进程的状态，如下是其中一些值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Constant for &#123;@link #importance&#125;: This process is running the * foreground UI; that is, it is the thing currently at the top of the screen * that the user is interacting with. */public static final int IMPORTANCE_FOREGROUND = 100;/** * Constant for &#123;@link #importance&#125;: This process is running a foreground * service, for example to perform music playback even while the user is * not immediately in the app. This generally indicates that the process * is doing something the user actively cares about. */public static final int IMPORTANCE_FOREGROUND_SERVICE = 125;/** * Constant for &#123;@link #importance&#125;: This process is running the foreground * UI, but the device is asleep so it is not visible to the user. This means * the user is not really aware of the process, because they can not see or * interact with it, but it is quite important because it what they expect to * return to once unlocking the device. */public static final int IMPORTANCE_TOP_SLEEPING = 150;/** * Constant for &#123;@link #importance&#125;: This process is running something * that is actively visible to the user, though not in the immediate * foreground. This may be running a window that is behind the current * foreground (so paused and with its state saved, not interacting with * the user, but visible to them to some degree); it may also be running * other services under the system's control that it inconsiders important. */public static final int IMPORTANCE_VISIBLE = 200;/** * Constant for &#123;@link #importance&#125;: This process is not something the user * is directly aware of, but is otherwise perceptible to them to some degree. */public static final int IMPORTANCE_PERCEPTIBLE = 230;/** * Constant for &#123;@link #importance&#125;: This process is running an * application that can not save its state, and thus can't be killed * while in the background. * @hide */public static final int IMPORTANCE_CANT_SAVE_STATE= 270;/** * Constant for &#123;@link #importance&#125;: This process is contains services * that should remain running. These are background services apps have * started, not something the user is aware of, so they may be killed by * the system relatively freely (though it is generally desired that they * stay running as long as they want to). */public static final int IMPORTANCE_SERVICE = 300;/** * Constant for &#123;@link #importance&#125;: This process process contains * cached code that is expendable, not actively running any app components * we care about. */public static final int IMPORTANCE_CACHED = 400;/** * @deprecated Renamed to &#123;@link #IMPORTANCE_CACHED&#125;. */public static final int IMPORTANCE_BACKGROUND = IMPORTANCE_CACHED;/** * Constant for &#123;@link #importance&#125;: This process is empty of any * actively running code. * @deprecated This value is no longer reported, use &#123;@link #IMPORTANCE_CACHED&#125; instead. */@Deprecatedpublic static final int IMPORTANCE_EMPTY = 500;/** * Constant for &#123;@link #importance&#125;: This process does not exist. */public static final int IMPORTANCE_GONE = 1000; 一般数值大于RunningAppProcessInfo.IMPORTANCE_SERVICE的进程都长时间没用或者空进程了 一般数值大于RunningAppProcessInfo.IMPORTANCE_VISIBLE的进程都是非可见进程，也就是在后台运行着 第三方清理软件清理的一般是大于IMPORTANCE_VISIBLE的值，所以要想不被杀死就需要将自己的进程降低到IMPORTANCE_VISIBLE以下，也就是可见进程的程度。在每一个Service中有一个方法叫startForeground,也就是以可见进程的模式启动，这里是在SDK源码中的实现与注释，可以看到，它会在通知栏持续显示一个通知，但只需要将id传为0即可避免通知的显示。当然要取消这种可见进程等级的设置只需要调stopForgeround即可。","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"Push","slug":"Push","permalink":"http://lichaoyu.com/tags/Push/"},{"name":"Polling","slug":"Polling","permalink":"http://lichaoyu.com/tags/Polling/"}]},{"title":"Java反射机制总结","slug":"2018-06-13_Java反射机制总结","date":"2018-06-13T05:04:46.000Z","updated":"2018-06-20T06:28:22.340Z","comments":true,"path":"2018/06/13/2018-06-13_Java反射机制总结/","link":"","permalink":"http://lichaoyu.com/2018/06/13/2018-06-13_Java反射机制总结/","excerpt":"","text":"Java反射机制总结反射的概念在Java中程序可以访问、检测和修改它自身状态或行为的一种能力。简单来说，就是只要给定类的名字，就可以知道这个类的所有属性和方法，这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。 反射的作用 在运行时判断任意一个对象所属的类； 在运行时获取类的对象； 在运行时访问Java对象的属性，方法以及构造方法等。 反射的优缺点优点： 可以实现动态创建对象和编译，最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。 缺点： （1）对性能有影响。 （2）使用反射相对来说不安全。 （3）破坏了类的封装性，可以通过反射获取这个类的私有方法和属性。 使用注意事项性能第一：反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用反射。 安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行。 内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用——代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 使用示例 关于Class Class是一个类，一个描述类的类（也就是描述类本身），封装了描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性 对象照镜子后（反射）可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。 对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 Class 对象只能由系统建立对象 一个类在 JVM 中只会有一个Class实例 获取Class有三种方法12345678910111213Class clazz = null;// 1.直接通过类名.class的方式得到clazz = Test.class;// 2.通过对象的getClass()方法获取Object obj = new Test();clazz = obj.getClass();// 3.通过全类名获取，用的比较多，但可能抛出ClassNotFoundException异常try &#123; clazz = Class.forName(\"com.lcy.demo.reflection.Test\"); System.out.println(\"通过全类名获取:\" + clazz);&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 利用newInstance创建对象：调用的类必须有无参构造器123456Class clazz = Class.forName(\"com.java.reflection.Person\"); //使用Class类的newInstance()方法创建类的一个对象 //实际调用的类的那个 无参数的构造器（这就是为什么写的类的时候，要写一个无参数的构造器，就是给反射用的） //一般的，一个类若声明了带参数的构造器，也要声明一个无参数的构造器 Object obj = clazz.newInstance(); System.out.println(obj); 输出 Person{name=’null’, age=0} Java类加载器 类加载器示例图 12345678910111213141516// 获取一个系统的类加载器ClassLoader classLoader = ClassLoader.getSystemClassLoader();System.out.println(\"系统类加载器：\" + classLoader);// 获取系统类加载器的父类加载器（扩展加载器）classLoader = classLoader.getParent();System.out.println(\"扩展加载器：\" + classLoader);// 获取扩展加载器的父类加载器// 输出为NULL，无法被Java程序直接引用classLoader = classLoader.getParent();System.out.println(\"启动类加载器\" + classLoader);// 测试当前类由哪个加载器加载，结果就是系统的类加载器classLoader = Class.forName(\"com.lcy.demo.reflection.Test\").getClassLoader();System.out.println(\"当前类由哪个类加载：\" + classLoader);// 测试JDK提供的Object类由哪个类加载器加载classLoader = Class.forName(\"java.lang.Object\").getClassLoader();System.out.println(\"Object类由哪个类加载：\" + classLoader); 系统的类加载器–&gt;sun.misc.LauncherAppClassLoader@43be2d65 扩展类加载器–&gt;sun.misc.LauncherExtClassLoader@7a9664a1 启动类加载器–&gt;null 当前类由哪个类加载器进行加载–&gt;sun.misc.Launcher$AppClassLoader@43be2d65 JDK提供的Object类由哪个类加载器加载–&gt;null getResourceAsStream()：类加载器的一个主要方法，获取类路径下的文件对应的输入流。 12345678910InputStream in = classLoader.getResourceAsStream(\"com/lcy/demo/reflection/test.properties\"); try &#123; Properties properties = new Properties(); properties.load(in); System.out.println(properties.getProperty(\"driver\")); System.out.println(new String(properties.getProperty(\"user\").getBytes(\"ISO-8859-1\"), \"UTF-8\")); System.out.println(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Method：类中方法获取clazz对应类中除私有方法外的所有方法 1Method[] methods = clazz.getMethods(); 获取clazz当前类中声明的所有方法 1Method[] declaredMethods = clazz.getDeclaredMethods(); 获取指定方法 1Method method = clazz.getDeclaredMethod(\"setName\", String.class); Invoke()12345Method method = clazz.getDeclaredMethod(\"privateMethod\");// 通过反射执行private方法 method.setAccessible(true);Object obj = clazz.newInstance();method.invoke(obj, \"lcy\"); Field字段123456789101112//1.1 获取Field的数组,私有字段也能获取 Field[] fields = clazz.getDeclaredFields(); //1.2 获取指定名字的Field（如果是私有的，见下面的4) Field field = clazz.getDeclaredField(\"name\"); Person person = new Person(\"ABC\", 12); //2、获取指定对象的Field的值 Object val = field.get(person); //3、设置指定对象的Field的值 field.set(person, \"changwen2\"); //4、若该字段是私有的，需要调用setAccessible(true)方法 Field field2 = clazz.getDeclaredField(\"age\"); field2.setAccessible(true); 构造器(Constructor)1234//1.获取Constructor对象 Constructor&lt;Person&gt; constructor = clazz.getConstructor(String.class, Integer.class); //2.调用构造器的newInstance()方法创建对象 Object obj= constructor.newInstance(\"changwen\", 11);","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://lichaoyu.com/tags/Java/"},{"name":"Reflection","slug":"Reflection","permalink":"http://lichaoyu.com/tags/Reflection/"}]},{"title":"Android8.0通知适配（NotificationChannel）","slug":"android8-0-notification","date":"2018-05-17T05:10:37.000Z","updated":"2018-06-16T03:59:05.551Z","comments":true,"path":"2018/05/17/android8-0-notification/","link":"","permalink":"http://lichaoyu.com/2018/05/17/android8-0-notification/","excerpt":"","text":"Android8.0 NotificationCannelNotificationCannel是Android8.0的新特性，如果App的targetSDKVersion&gt;=26，没有设置channel通知渠道的话，就会导致通知无法展示。 Android O 引入了 通知渠道（Notification Channels），以提供统一的系统来帮助用户管理通知，如果是针对 android O 为目标平台时，必须实现一个或者多个通知渠道，以向用户显示通知。比如聊天软件，为每个聊天组设置一个通知渠道，指定特定声音、灯光等配置。 国内app基本都集成了第三方推送SDK，目前使用的两个推送平台都还没进行适配，所以还需要等第三方出新版本并集成，如果我们app内部也有自己弹出通知逻辑，最好和他们保持一致，毕竟app内设置多个通知渠道不方便维护。 报错内容： Failed to post notification on channel “null” Target Api is 26 原因： 目前NotificationCompat.Builder(context)方法已deprecated，在Android 8.0系统推荐使用NotificationCompat.Builder(context, channelId)方法，为通知设置相应渠道。 解决方案： 下面是一个通知管理类，包含Android8.0通知处理逻辑，仅供参考。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class NotificationUtils extends ContextWrapper &#123; private NotificationManager manager; public static final int NOTIFICATION_ID = 1; public static final String CHANNEL_ID = \"channel_1\"; public static final String CHANNEL_NAME = \"channel_name_1\"; public NotificationUtils(Context context) &#123; super(context); &#125; /** * 创建通知渠道 **/ @RequiresApi(api = Build.VERSION_CODES.O) public void createNotificationChannel() &#123; NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH); channel.enableLights(true); //是否在桌面icon右上角展示小红点 channel.setLightColor(Color.GREEN); //小红点颜色 channel.setShowBadge(true); //是否在久按桌面图标时显示此渠道的通知 getManager().createNotificationChannel(channel); &#125; private NotificationManager getManager() &#123; if (manager == null) &#123; manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; return manager; &#125; /** * 初始化NotificationCompat.Builder * 适配android 8.0 */ private NotificationCompat.Builder getNotification(String title, String content, NotificationItem item) &#123; NotificationCompat.Builder builder; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; createNotificationChannel(); //设置渠道，channelId要与创建时的channelId对应 builder = new NotificationCompat.Builder(getApplicationContext(), CHANNEL_ID); &#125; else &#123; builder = new NotificationCompat.Builder(getApplicationContext()); &#125; builder.setContentTitle(title) .setContentText(content) .setSmallIcon(android.R.drawable.stat_notify_more) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.logo)) .setWhen(System.currentTimeMillis()) .setPriority(NotificationCompat.PRIORITY_HIGH) .setDefaults(NotificationCompat.DEFAULT_SOUND | NotificationCompat .DEFAULT_VIBRATE) // 设置默认铃声与震动 .setFullScreenIntent(initPendingIntent(item), true) //悬挂式通知 .setContentIntent(initPendingIntent(item)) .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) // 锁屏通知，显示通知全部内容 .setAutoCancel(true); return builder; &#125; /** * 点击通知后跳转意图，开发者可自行定义item类，根据不同的type处理各业务逻辑，如相应跳转等。 */ private PendingIntent initPendingIntent(NotificationItem item) &#123; Intent intent = new Intent(getApplicationContext(), MainActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); return pi; &#125; /** * 显示通知 */ public void sendNotification(String title, String content, NotificationItem item) &#123; Notification notification = getNotification(title, content, item).build(); getManager().notify(NOTIFICATION_ID, notification); &#125; /** * 取消通知 */ public void cancelNotification() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; getManager().deleteNotificationChannel(CHANNEL_ID); &#125; getManager().cancel(NOTIFICATION_ID); &#125;&#125; 管理类具体使用： 12NotificationUtils notificationUtils = new NotificationUtils(this);notificationUtils.sendNotification(\"通知标题\", \"通知内容\", entity); Android Notification 四种方式部分参考 https://blog.csdn.net/yxncl/article/details/72801230 实现通知的一般步骤 获取NotificationManager实例来管理通知； 实例Notification对象； 管理点击事件Intent，PendingIntent； 发送通知(notificationManager.notify(id, notification)) 使用NotificationCompat.Builder是为了解决Notification.Builder的兼容问题，可最低支持API Level 4。 普通通知获取NotificationManager实例对象： 1NotificationManager manager = (NotificationManager) context.getSystemService(NOTIFICATION_SERVICE); 通过NotificationCompat.Builder创建Notification对象，可以通过builder相应方法进行设置： 1234567891011Notification notication = new NotificationCompat.Builder(this) .setContentTitle(title) .setContentText(content) .setContentIntent(pi) //设置点击逻辑 .setOngoing(true) //true则用户不能手动清除 setAutoCancel(true)点击之后消失 .setPriority(NotificationCompat.PRIORITY_HIGH) // 设置通知优先级 .setSmallIcon(R.mipmap.ic_launcher_round) // 设置状态栏小图标 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) // 设置下拉通知栏中的icon .setWhen(System.currentTimeMillis()) // 设置通知显示时间为当前时间戳，立即显示 .setDefaults(NotificationCompat.DEFAULT_SOUND | NotificationCompat.DEFAULT_VIBRATE) // 设置默认声音和震动效果 .build(); 设置点击通知后逻辑，自行根据相应业务： 123Intent intent = new Intent(this, NotificationActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); 显示通知，参数一的id指定通知的唯一id： 1manager.notify(NOTIFICATION_ID, notification); 取消通知： 1manager.cancel(NOTIFICATION_ID); 悬挂式通知1builder.setFullScreenIntent(pi, true) setPriority()方法共有5个等级： PRIORITY_MIN - 最低级别（-2）； PRIORITY_LOW - 较低级别（-1）； PRIORITY_DEFAULT - 默认级别（0）； PRIORITY_HIGH - 较高级别（1）； PRIORITY_MAX - 最高级别（2）； 当发出此类型的通知时，通知会以悬挂的方法显示在屏幕上。 折叠通知折叠式同时需要借助 RemoteViews 来实现 123456789101112131415161718192021222324Notification builder = new NotificationCompat.Builder(Context); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.sina.com&quot;)); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); // 未下拉的样式 R.layout.collapsed RemoteViews collapsed = new RemoteViews(getPackageName(), R.layout.collapsed); collapsed.setTextViewText(R.id.collapsed_text, &quot;关闭状态&quot;); //下拉后的样式R.layout.show RemoteViews show = new RemoteViews(getPackageName(), R.layout.show); Notification notify = builder.setAutoCancel(true) .setSmallIcon(R.mipmap.ic_launcher_round) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi) .setContentText(&quot;新浪微博&quot;) .setCustomContentView(collapsed)//下拉前 .setCustomBigContentView(show)//下拉后 .build(); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.notify(0, notify); 锁屏通知1builder.setVisibility(NotificationCompat.VISIBILITY_PUBLIC) setVisibility() 方法共有三个选值： VISIBILITY_PRIVATE : 显示基本信息，如通知的图标，但隐藏通知的全部内容； VISIBILITY_PUBLIC : 显示通知的全部内容； VISIBILITY_SECRET : 不显示任何内容，包括图标。 不足之处欢迎指出，码农不易，携手共进^~^","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"Android8.0","slug":"Android8-0","permalink":"http://lichaoyu.com/tags/Android8-0/"},{"name":"Notification","slug":"Notification","permalink":"http://lichaoyu.com/tags/Notification/"}]},{"title":"ES6的十大特性","slug":"ES6的十大特性","date":"2018-05-13T15:59:23.000Z","updated":"2018-06-16T03:59:19.883Z","comments":true,"path":"2018/05/13/ES6的十大特性/","link":"","permalink":"http://lichaoyu.com/2018/05/13/ES6的十大特性/","excerpt":"","text":"你好ES6","categories":[{"name":"FE","slug":"FE","permalink":"http://lichaoyu.com/categories/FE/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://lichaoyu.com/tags/IT/"},{"name":"前端","slug":"前端","permalink":"http://lichaoyu.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://lichaoyu.com/tags/JavaScript/"}]},{"title":"Android Studio","slug":"android1","date":"2018-05-07T09:05:06.000Z","updated":"2018-06-16T03:58:52.496Z","comments":true,"path":"2018/05/07/android1/","link":"","permalink":"http://lichaoyu.com/2018/05/07/android1/","excerpt":"","text":"Welcome to my own zone, first of all, let me introduce something to you, then you can communicate with me for android development problems, Let’s start. 第一步这是第一步123public static void main(String[] args)&#123; println(\"Hello World!\");&#125; 第二步这是第二步 123456789101112131415public static AlertDialog showDefaultDialog(Activity activity, @StringRes int title, @StringRes int content, boolean cancelable, @StringRes int confirm, @StringRes int cancel, DialogInterface.OnClickListener confirmListener, DialogInterface.OnClickListener cancelListener) &#123; return new AlertDialog.Builder(activity) .setTitle(title) .setMessage(content) .setCancelable(cancelable) .setNegativeButton(confirm, confirmListener) .setPositiveButton(cancel, cancelListener) .setOnDismissListener(new DialogInterface.OnDismissListener() &#123; @Override public void onDismiss(DialogInterface dialog) &#123; dialog.dismiss(); &#125; &#125;) .show(); &#125; 第三步这是第三步 123456789101112131415161718192021222324addCompositeDisposable( getBaseModel().logout(), new RxObserver&lt;Object&gt;() &#123; /** * 数据流传递的结果 * * @param result */ @Override public void response(Object result) &#123; getBaseView().onLogoutSuccess(App.mAppContext.getString(R.string.log_out)); &#125; /** * 数据流过程中出现错误 * * @param message 不为空 */ @Override public void error(String message) &#123; getBaseView().onLogoutFail(message); &#125; &#125; );","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://lichaoyu.com/tags/Java/"},{"name":"IT","slug":"IT","permalink":"http://lichaoyu.com/tags/IT/"},{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-05T12:19:50.665Z","updated":"2018-05-07T05:35:01.707Z","comments":true,"path":"2018/05/05/hello-world/","link":"","permalink":"http://lichaoyu.com/2018/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}