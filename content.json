{"meta":{"title":"Born To Do","subtitle":null,"description":"There is nothing you can complain about, it all depends on human effort.","author":"Charlie","url":"http://lichaoyu.com"},"pages":[{"title":"About","date":"2018-07-09T02:13:22.251Z","updated":"2018-05-05T17:06:04.321Z","comments":true,"path":"about/index.html","permalink":"http://lichaoyu.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-07-09T02:12:46.735Z","updated":"2018-07-09T02:01:58.923Z","comments":true,"path":"categories/index.html","permalink":"http://lichaoyu.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-07-09T02:13:06.481Z","updated":"2018-05-05T17:06:04.321Z","comments":true,"path":"tags/index.html","permalink":"http://lichaoyu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"培养解决问题的能力","slug":"2018-08-29-培养解决问题的能力","date":"2018-08-29T12:07:38.000Z","updated":"2018-08-29T12:11:00.435Z","comments":true,"path":"2018/08/29/2018-08-29-培养解决问题的能力/","link":"","permalink":"http://lichaoyu.com/2018/08/29/2018-08-29-培养解决问题的能力/","excerpt":"","text":"我们身边总有这么两类人，一类人总是在抛出问题，不断向别人寻求帮助，人称trouble maker。还有一类人仿佛什么都会，团队中遇到问题都会去找他解决，人称trouble solver。 第一类人的思想依赖越发严重，逐渐发展成臭名昭著的伸手党，变身团队中的价值索取者，逐渐被众人远离。第二类人在成长过程中，解决问题的能力不断增强，逐渐变成团队中的价值提供者，变得受人欢迎。 我们大多都希望自己远离第一类人，接近并学习第二类人，并希望自己变成第二类人。那么我们该如何培养这种解决问题的能力呢？ 1.正确的澄清问题大多人提出问题的时候，通常都描述不清楚自己的问题，讲一大堆东西，大多是现状或者心理感受。更多的是表达自己的情绪，希望别人了解你。但自己都不清楚问题在哪里，那么怎么能解决问题呢？ 所以解决问题的第一步，是要澄清问题，真正的问题是要从现状寻找到引起现状的最小可能原因。比如下面的例子。 “我电脑不能用了” —&gt; “我电脑开不起来机” —&gt; “我电脑开机黑屏，显示 no disk”–&gt; “我电脑昨晚换了个硬盘，今早开机的时候显示no disk” 从现状不断的探究，寻找到最小不可观测疑惑点，然后针对最小疑惑此点寻找对策，进而才能解决问题。而且大多数问题当你澄清到疑惑点时，你自己就可以解决了。 我十分赞同的一句话：提出问题是解决问题的一半，没有问题才是最大的问题。 trouble solver并不是一开始就知道问题的答案的，而是因为他对问题有探究的意识，进而可以探究出问题的答案。 下面是一个较好的问题澄清模型，来自马琦博士。 问题澄清模型V2.0@马琦 【背景】（事情的起源、做事的意义和目的） 【现状】（现在的情况介绍、有哪些资源可以使用、有哪些限制因素等等） 【期待】（期待达到什么效果？理想的状态是什么样子？） 【尝试】（做了哪些尝试、取得什么成效、还有哪些不足） 【问题】（现在还存在哪些问题？你最想解决的问题是哪个？） 比如： 您好。我在……过程中，遇到了什么问题，具体表现在……，我尝试了……，还是不能解决，你能不能帮我解决一下，谢谢。 2.从质疑开始质疑假的，会让我们发现真理。质疑真理，会更让我们捍卫真理。 所以解决问题，一定要学会质疑，质疑外界，也要质疑自己。 有质疑的意识，可以帮助你把质疑点观测区域放大，进而发现出真正的质疑点，从而解决问题。 3.培养逻辑良好的逻辑分析能力是解决问题最重要的工具之一，我们要养成归纳与推理的习惯。 确定问题有一个很好的方法，那就是单因素对照试验（控制单一可变变量，用实验组和对照组确定问题），这个是不断的缩小可怀疑对象、直到找到问题的最好方法。 尽量避免单因素决策法（就是认为只需要做好某件事就可以达成目的）！世界是复杂的，解决任何一个问题都可能很复杂！比如你要解决成功的问题！只需要靠坚持就行吗？ 坚持是成功的必要条件！而不是充分条件！放弃也是成功的必要条件！（《拆掉思维里的墙》） 生活中少用 “只要…..就可以什么…”“这个东西不就是…..”这种句式，避免使用过度的单因素决策！也避免把问题简化。 4.你的问题并不是特例你的问题并不是那么特别，减少使用 “虽然你的方法说的很好，但是我的情况是……”的句式。全世界60亿人.你的问题大多数人已经遇到过，互联网上大多有现成的答案。就算没有现成的答案，也有类似的答案！ 而且别人并不是如同你那么了解自己，别人的方法自然也不一定能适用自己，要将别人已有的答案结合自己的情况，整理出自己的答案！ 5.勤用搜索养成遇到问题先使用搜索引擎解决的意识！多用谷歌、百度、维基百科。 掌握搜索引擎的高级搜索方法（你看到这里第一反应是留言问我高级搜索方法是什么还是自己去搜索一下？）。 我解决问题的方式： 1.思考、钻研 2.搜索引擎搜索（谷歌、百度） 3.书籍、论文 4.去论坛问、去根据关键词搜索QQ群 5.去发邮件问官方！ 6.请教别人（一定是经过认真思考过的问题，而且是给思路、不是给答案） 6.要学习变换思维框架有时面对问题苦苦求索而不得解时，可能就是局限性的问题了。面对这种情况，不妨尝试跳出思维框架，或许有焕然一新的思路。 思考框架，就是你思考这个问题假设的基准。 比如在群里讨论 技术的未来时，有人提出 “人类是技术的一个宿主，等技术继续成长之后，人类说不定就灭亡了，技术会寻找下一个宿主”这种就很值得深思，它跳出来人类中心主义的思维框架，得出了不一样的答案。 比如刚加入公司的时候，在自我介绍的环节，我看到每个人的自我介绍最开始的话是“大家好、我是…..”，那么我就在想，我能不能跳出这个定势思维？于是我故意在自我介绍的结尾才说出名字，事实证明，效果不错。 我们要经常拆掉思维中那些定势之墙！避免解决问题的思考局限于几个特定的点！（幽默是个很好的方法！） 7.用潜意识思考显意识能处理较复杂的任务，逻辑性强，但是单进程。潜意识可以同时进行多项任务（比如你在此刻看这篇文章的时候，潜意识控制着你的呼吸、心跳、提问、眼睛都再进行正常的生理活动），而且发散性好。（《思考快与慢》） 用潜意识思考就是把问题放到思绪中，时不时的去想一想，用无意识的思考去思考。这种思考方式比显意识思考更具有发散性，有意识地用潜意识思考问题，经常会带给你惊喜。 8.思想独立思想独立是这个世界最难的事情。信息爆炸、人的社会属性不断加强、产品过度（帮助你解决问题的方式）、思想教化都让大众的思考能力逐渐钝化。你不用太聪明、不用多厉害，依然饿了可以点外卖、要出去可以叫车，可以“快乐”地度过一生。 王东岳先生《物演通论》提出的“递弱代偿”原理指出， 世间之物，后衍的物种的生存的顽强程度总是呈现递减态势。250万年之前，非洲的人属开始演化，他们需要有强壮的肌肉、顽强的体魄、敏锐的视觉还要依赖良好的“运气”，才能侥幸存活，最终完成繁衍的生物使命。而250年之后的现在，肥胖、近视席卷了大部分人类，而我们大多都可以活到60岁以上。那么在很多年之后，那时的人类是不是连思考的能力都不需要有就能获得更好的幸福？那时他们还叫人类吗？ 保持思想的独立，是努力在这个彼此依赖逐渐严重的社会中保持那么一点点自我！面对问题，有自己的思考方式、看待角度以及解决方式。是成为一个完整的人的重要特征。 9.坚持自学互联网的时代，知识是扁平的在，只要你想学，你可以去自学所有你想学的东西。 多用自学的方式去学习一些东西，在增强你个人竞争力的同时，你的个人学习能力和解决问题的能力也会不断加强，独立解决问题的意识也会逐渐加强。这是提高解决问题能力的最好的办法。 10.跨情景切换我在学习专业知识的时候，经常使用搜索引擎获取答案。然而，在实际生活中遇到一些问题的时候，往往第一时间想的不是去搜索。比如错过了微信群里的通知、资料时，我第一反应是发问，看看有没有群里的人丢出来，但是实际上呢？我其实只需要用下群搜索就能知道结果啊？我可是自诩为搜索引擎的重度使用者呢？怎么会忘了呢？ 刘未朋先生的《暗时间》里面对以上情况做了如下描述（有删改）： 我们解决问题有两个思维步骤：一是根据问题情境线索从记忆系统当中提取以往成功过的方案，如果该方案可以解决问题，则停止搜寻，在上面的案例中，留言发问（在群里说过这个事情，那么肯定有人知道）是我在成为搜索引擎重度使用者之前建立起来的、针对这类情境的特定习惯，而且这个习惯满足可行原则，因此，在这样的思维定式下，我不假思索地就沿袭了旧习惯，而没有成功地将在另外一个问题领域建立的更好的方法推广到这个问题中来。 这就是知识经验跨情境切换的案例，刘未朋先生提出的解决办法是，多观察反省、多抽象本质，从而举一反三。 11.知识的迁移知乎大神采铜老师在新书《精进》中提到，如果要成为一个很厉害的人，必须有复合型知识结构，善于在所学的知识之间创造关联。让不同的知识进行融合，洞察知识背后的深层结构。发现它们潜在的相似性、互补性、启发性。 通过知识的抽象和关联，将知识进行迁移应用，从而更加多方面的思考问题，解决问题。","categories":[{"name":"Thoughts","slug":"Thoughts","permalink":"http://lichaoyu.com/categories/Thoughts/"}],"tags":[]},{"title":"正则表达式总结","slug":"2018-08-22-正则表达式总结","date":"2018-08-22T10:03:53.000Z","updated":"2018-08-22T10:16:28.744Z","comments":true,"path":"2018/08/22/2018-08-22-正则表达式总结/","link":"","permalink":"http://lichaoyu.com/2018/08/22/2018-08-22-正则表达式总结/","excerpt":"","text":"Android 元字符和普通字符大部分字符，包括所有的字母和数字字符，是普通字符。它们只能匹配自己，如cat。 有一些被称为元字符的特殊字符，可以匹配一些特殊规则。 注意：不做特殊说明，正则表达式中是区分大小写的。但是，几乎所有正则表达式的实现，都会提供一个Flag用来控制是否区分大小写。 点“.” 可以匹配任意一个字符 反斜杠“\\”可以忽略元字符，即使元字符回到普通字符，如c\\.t只能匹配c.t，它本身也是一个元字符 ==.不能用于匹配换行符，实现环境中通常会提供一个Flag标志位来控制这一点== 字符类字符类是一组子啊方括号内的字符，表示可以匹配其中的任何一个字符。 正则表达式c[aeiou]t，表示可以匹配的字符串是”以c开头，接着是aeiou中的任何一个字符，最后以t结尾”。 正则表达式[0123456789]表示匹配任意一个整数。 正则表达式[a]表示匹配单字符a。 [\\[\\]ab]表示匹配的字符为”[“或者”]”或者”a”,或者”b”。 在字符类中，字符的重复和出现顺序并不重要，[dabaaabcc]与[abc]是相同的。 &emsp;&emsp;重要提示：字符类中和字符类外的规则有时不同，一些字符在字符类中是元字符，在字符类外是普通字符。一些字符正好相反。还有一些字符在字符类中和字符类外都是元字符，这要视情况而定！ &emsp;&emsp;比如，.表示匹配任意一个字符，而[.]表示匹配一个全角句号。这不是一回事！ 字符类的范围使用短横线来表示匹配字母或数字的范围。例如[b-f]与[b,c,d,e,f]相同，都是匹配bcdef中的一个字符。 字符类的反义你可以在字符类的起始位放一个反义符。 [^a]表示匹配任何不是“a”的字符 [^a-zA-Z0-9]表示匹配任何不是字母也不是数字的字符 [\\\\^abc]匹配一个为“^”或者a或者b或者c的字符 [\\^\\\\^]表示匹配任何不为“^”的字符 转义字符类 \\d这个正则表达式与[0-9]作用相同，都是匹配任何一个数字。（要匹配\\d,应该使用正则表达式\\\\d） \\D与[^0-9]相同，表示匹配一个非数字字符。 \\w与[0-9A-Za-z]相同，都表示匹配一个数字或字母字符 \\W与[^0-9A-Za-z_]相同，表示匹配一个非数字同时不是字母的字符。 \\s意味着匹配一个空字符（空格，制表符，回车或者换行） \\S表示匹配一个非空字符。 重复在字符或字符集之后，使用{}大括号来表示重复。 正则表达式a{1}与a意思相同，都表示匹配字母a a{3}表示匹配字符串“aaa” a{0}表示匹配空字符串。从这个正则表达式本身来看，它毫无意义。如果你对任何文本执行这样的正则表达式，你可以定位到搜索的起始位置，即使文本为空。 a\\{2\\}表示匹配字符串“a{2}” 在字符类中，大括号没有特殊含义。[{}]表示匹配一个左边的大括号，或者一个右边的大括号 注意：重复字符是没有记忆性的，比如[abc]{2}表示先匹配”a或者b或者c”，再匹配”a或者b或者c”，与匹配”aa或者ab或者ac或者ba或者bb或者bc或者ca或者cb或者cc”一样。[abc]{2}并不能表示匹配”aa或者bb或者cc”。 指定重复次数范围重复次数是可以指定范围的 x{4,4}与x{4}相同 colou{0,1}r表示匹配colour或者color a{3,5}表示匹配aaaaa或者aaaa或者aaa 重复次数的范围可以是开区间 a{1，}表示匹配一个或一个以上的连续字符a。依然是匹配最长字符串。当找到第一个a之后，正则表达式会尝试匹配尽量多个的连续字母a。 .{0,}表示匹配任意内容。无论你输入的文本是什么，即使是一个空字符串，这个正则表达式都会成功匹配全文并返回结果。 关于重复的转义字符-？与{0,1}相同，比如，colou?r表示匹配colour或者color 与{0,}相同。比如，.表示匹配任意内容 +与{1，}相同。比如,\\w+表示匹配一个词。其中”一个词”表示由一个或一个以上的字符组成的字符串，比如_var或者AccountName1. 非贪婪匹配正则表达式 “.*” 表示匹配双引号，之后是任意内容，之后再匹配一个双引号。注意，其中匹配任意内容也可以是双引号。通常情况下，这并不是很有用。通过在句尾加上一个问号，可以使得字符串重复不再匹配最长字符。 “.*?”表示先匹配一个双引号，然后匹配最少的字符，然后是一个双引号，与上面两个例子不同，这很有用。 选择匹配使用|来分割可以匹配的不同选择 cat|dog表示匹配”cat”或者”dog” red|blue|以及red||blue以及|red|blue都表示匹配red或者blue或者一个空字符串 a|b|c与[abc]相同 cat|dog|\\|表示匹配”cat”或者”dog”或者一个分隔符”|“ [cat|dog]表示匹配a或者c或者d或者g或者o或者t或者一个分隔符“|” 元组使用括号表示分组 单词分隔符-在单词和费单词之间有单词分隔符。在文本的开头和结尾通常也有单词分隔符。 \\b表示匹配一个单词分隔符 \\b\\w\\w\\w\\b表示匹配一个三字母单词 a\\ba表示匹配两个a中间有一个单词分隔符。这个正则表达式永远不会有匹配的字符，无论输入怎样的文本。 单词分隔符本身并不是字符，它的宽度为0 换行符一篇文本中可以有一行或多行，行与行之间由换行符分隔。 注意，所有的文本都是以一行结束的，而不是以换行符结束。但是，任意一行都可能为空，包括最后一行。 行的起始位置，是在换行符和下一行首字符之间的空间。考虑到单词分隔符，文本的起始位置也可以当做是首行位置。 最后一行是最后一行的尾字符和换行符之间的空间。考虑到单词分隔符，文本的结束也可以认为是行的结束。 那么新的格式表示如下: Start-of-line, line, end-of-line Line break Start-of-line, line, end-of-line Line break … Line break Start-of-line, line, end-of-line 基于上述概念: ^表示匹配行的开始位置 $表示匹配行的结束位置 ^&amp;表示一个空行 ^.*&amp; 表示匹配全文内容，因为行的开始符号也是一个字符，”.”会匹配这个符号。找到单独的一行，可以使用 ^.*?$ \\\\^\\$表示匹配字符串“$” [$]表示匹配一个$。但是，[^]不是合法的正则表达式。记住在方括号中，字符有不同的特殊含义。要想在方括号内匹配^，必须用[\\^] 文本分界在很多的正则表达式实现中，将^和$作为文本的开始符号和结束符号。 还有一些实现中，用\\A和\\z作为文本的开始和结束符号。 捕捉和替换= 捕获元组使用括号可以捕获子串。捕获组从左向右编，也就是只需要==对左括号计数==。 在一些正则表达式的实现中，你可以从零开始编号，编号0代表整句话。 在其他的实现中，如果没有指定捕获组，那么捕获组1会自动地填入捕获组0的信息。 替换假如你使用了一个正则表达式去匹配字符串，你可以描述另外一个字符串来替换其中的匹配字符。用来替换的字符串称为替换表达式。 $0 $1 $2 表示捕获组0，1，2。 23h59 –&gt; 匹配：(\\d\\d)h(\\d\\d)–&gt; 替换：$1:$2 –&gt; 23:59 反向引用在一个正则表达式中，你也可以引用捕获组。 比如，[abc]{2}表示匹配aa或者ab或者ac或者ba或者bb或者bc或者ca或者cb或者cc.但是{[abc]}\\1表示只匹配aa或者bb或者cc. 使用正则表达式编程 在java中，过度使用反斜杠，匹配反斜杠或者是左边方括号，或者右边方括号的正则表达式从[\\\\\\[\\]] 变为String re = “[\\\\\\\\\\\\[\\\\]]” 在其他语言中，正则表达式是由特殊标明的，比如用/ 。比如在JavaScript中，找到URL必须使用var regExp = /https?:\\/\\//; 注意事项 当你动态创建一个正则表达式的时候请特别小心。如果你使用的字符串不够完善的话，可能会有意想不到的匹配结果。这可能导致语法错误，更糟糕的是，你的正则表达式语法正确，但是结果无法预料。 将正则表达式字符串加入反复运行的程序中，是一种开销很大的操作。如果你可以在循环中避免使用正则表达式，你可以大大提高效率。 输入验证 信用卡号 eg:在不先过滤掉所有的非数字字符的情况下，使用正则表达式验证卡号的正确性。 \\D(\\d\\D){16} 不要使用正则表达式来验证姓名。实际上，即使可以，也不要企图验证姓名。 首先，这样的验证很难是精确的，第二，即使一个电子邮件地址可以成功匹配正则表达式，也不代表这个邮箱实际存在。邮箱的唯一验证方法，是发送验证邮件。 不要使用正则表达式来解析HTML或者XML 总结 字符: a b c d 1 2 3 4 etc. 字符类: . [abc][a-z] \\d \\w \\s . 代表任何字符 \\d 表示“数字” \\w 表示”字母”, [0-9A-Za-z_] \\s 表示“空格,制表符,回车或换行符” 否定字符类: [^abc] \\D \\W \\S 重复: {4} {3,16} {1,} ? * + ? 表示 “零次或一次” * 表示 “大于零次” + 表示 “一次或一次以上” 如果不加上？，所有的重复都是最长匹配的（贪婪） 分组: (Septem|Octo|Novem|Decem)ber 词，行以及文本的分隔: \\b ^ $ \\A \\z 转义字符: \\1 \\2 \\3 etc. (在匹配表达式和替换表达式中都可用) 元字符: . \\ [ ] { } ? * + | ( ) ^ $ 在字符类中使用元字符: [ ] \\ - ^ 使用反斜杠可以忽略元字符: \\","categories":[{"name":"正则","slug":"正则","permalink":"http://lichaoyu.com/categories/正则/"}],"tags":[{"name":"Regular Expression","slug":"Regular-Expression","permalink":"http://lichaoyu.com/tags/Regular-Expression/"}]},{"title":"Android各版本新特性总结","slug":"2018-07-16-Android各版本新特性总结","date":"2018-07-16T15:26:28.000Z","updated":"2018-08-13T05:37:31.865Z","comments":true,"path":"2018/07/16/2018-07-16-Android各版本新特性总结/","link":"","permalink":"http://lichaoyu.com/2018/07/16/2018-07-16-Android各版本新特性总结/","excerpt":"","text":"Android各版本新特性总结持续更新中。。。 Android 9.0 室内WIFI定位 “刘海”屏幕支持 通知 增强体验 通道设置、广播以及免打扰 多相机支持和相机更新 新的图片解码 动画 HDR VP9视频，HEIF图像压缩和媒体API JobScheduler中的数据成本敏感度 神经网络API 1.1 改进表单自动填充 安全增强 Android 备份加密 Android 8.1 Android Go 简介 人工智能神经网络 API(如：TensorFlow) 自动填充框架更新 Notification 通知变更 EditText 更新 WebView 安全浏览更新 视频缩略图提取器更新 共享内存API WallpaperColors API 指纹更新 Android 8.0 APP“安装未知应用”功能默认被限制 优化通知 通知渠道 Notification Channel 通知标志 休眠 通知超时 通知设置 通知清除 自动填充框架 画中画模式：清单中Activity设置android:supportsPictureInPicture 可下载字体：FontRequest XML 中的字体 自动调整 TextView 的大小 自适应图标 颜色管理 WebView API 多显示器支持 统一的布局外边距和内边距 指针捕获 应用类别 Android TV 启动器 AnimatorSet 新的 StrictMode 检测程序 缓存数据 findViewById() 签名变更 权限 更新的 Java 支持 Android 7.1 加入重启按钮 App圆形图标 添加新的Emoji Android 7.0 分屏多任务 进入后台多任务管理页面，然后按住其中一个卡片，然后向上拖动至顶部即可开启分屏多任务，支持上下分栏和左右分栏，允许拖动中间的分割线调整两个APP所占的比例。 全新下拉快捷开关页 Android 7.0中，下拉打开通知栏顶部即可显示5个用户常用的快捷开关，支持单击开关以及长按进入对应设置。如果继续下拉通知栏即可显示全部快捷开关，此外在快捷开关页右下角也会显示一个编辑按钮，点击之后即可自定义添加/删除快捷开关，或拖动进行排序。 新通知消息 通知消息快捷回复 加入了全新的API，支持第三方应用通知的快捷操作和回复，例如来电会以横幅方式在屏幕顶部出现，提供接听/挂断两个按钮；信息/社交类应用通知，还可以直接打开键盘，在输入栏里进行快捷回复。 通知消息归拢 Android7.0会将同一应用的多条通知提示消息归拢为一项，点击该项即可展开此前的全部通知，允许用户对每个通知执行单独操作。 流量保护模式 新增的流量保护模式不仅可以禁止应用在后台使用流量，还会进一步减少该应用在前台时的流量使用。推测其有可能使用了类似Chrome浏览器的数据压缩技术。此外，谷歌还扩展了ConnectivityManager API的能力，使得应用可以检测系统是否开启了流量保护模式，或者检测自己是否在白名单中。Android7.0允许用户单独针对每个应用，选择是否开启数据保护模式。 菜单键快速应用切换 支持VR 引入JIT编译器 画中画 Project Svelte: 后台优化 Android 6.0 动态权限管理 Android 6.0引入了动态权限管理，将标记为危险的权限从安装时权限模型移动到运行时权限模型。 安装时权限模型(Android5.1以及更早)：用户在应用安装和更新时，对危险权限授权。但是OEM和运行商预装的应用将自动预授权。 运行时权限(Android6.0及以后)：用户在应用运行时，对应用授予危险权限。由应用决定何时去申请权限（例如，在应用启动时或者用户访问某个特性时），但必须容许用户来授予或者拒绝应用对特定权限组的访问。OEM和运营商可以预装应用，但是不能对权限进行预授权。 运行时权限提供给用户关于应用所需权限更多的相关上下文和可视性，这也让开发者帮助用户更好的理解：为什么应用需要所请求的权限，授权将有什么样的好处，拒绝将有何种不便。用户可以通过设置中的菜单来撤销应用的权限。 指纹识别Finger Support 说到指纹识别，很多用户都会觉得现在的中高端android手机都支持，但事实上这些android手机的指纹识别都是各个厂商自行开发的并没有系统底层的支持。Android 6.0则在系统层面加入指纹识别，能提供原生指纹识别API，这不但降低了厂商开发指纹识别模块的成本，最重要的是原生指纹识别将会大大提升android手机的指纹识别支付安全性 电池管理 Android 6.0使用下列特性来延长电池使用时间： App Standby（应用待机）: 系统可以将未使用的应用置为AppStandby模式，临时限制这些应用的网络访问，延迟同步和后台job Doze（瞌睡）: 如果用户在某个时间期限内未主动使用设备（屏幕关闭、设备静止），平台将进入深度睡眠状态。因为该特性要求平台检测静止状态，因此只有那些在Sensor HAL中实现了显式移动检测API的设备中才有效。 Exemptions（豁免）: 预装在设备上的系统应用和云消息服务，默认通常被豁免。应用开发者可以要求其应用使用这种设定。用户也可以在设置中来豁免某些应用。 Android Pay Android支付统一标准。新的M系统中集成了Android Pay。其特性在于简洁、安全、可选性。Android Pay是一个开放性平台，用户可以选择谷歌的服务或者使用银行的APP来使用它，Android Pay支持4.4以后的系统设备，Google宣布Android Pay已经与美国三大运营商700多家商店达成合作，支付功能可以使用指纹支付。 存储 在之前，安卓系统虽然可以支持TF卡扩展，但TF卡扩展的容量只能当成外置存储。虽然用户可以把照片、音乐等内容放进去，但App不能安装到其中。在安卓6.0中，当首次插入TF卡的时候，系统会询问会将TF卡作为外置还是内置储存。如果选择作为内置存储，系统则会对TF卡格式化并加密——注意，这会丢失数据！然后，TF卡的容量就和设备的内置存储融合了。 取消支持 Apache HTTP 客户端 BoringSSL 硬件标识符访问权 通知 音频管理器变更 支持文本选择 Android 密钥库不再支持 DSA。但仍支持 ECDSA WLAN 和网络连接变更 相机服务变更 APK 验证 USB 连接 Android 5.0 Android Runtime (ART)默认运行平台设置 支持64位ART虚拟机。新系统放弃了之前一直使用的Dalvik虚拟机，改用了ART模式，实现了真正的跨平台编译。ART虚拟机编译器在内存占用及应用程序加载时间上进行了大幅提升，谷歌承诺所有性能都会比原来提升一倍。另外，对64位的支持也让ART虚拟机如鱼得水，开发者可以针对像ART Cortex-A57这样的64位架构核心开发应用程序。 Android L支持更大的寄存器，支持新的指令集，提升了内存寻址空间，未来Android智能手机将支持4GB以上的内存。 全新通知中心设计 Material Design 样式 声音和振动 锁定屏幕可见性 媒体播放 - 浮动通知 Google在android L中加入了全新风格的通知系统。改进后的通知系统会优先显示对用户来说比较重要的信息，而将不太紧急的内容隐藏起来。用户只需啊哟向下滑动就可以查看全部的通知内容。 新的通知系统另外一个很酷的新功能是在锁屏界面也可以直接查看通知消息了。不仅如此，用户还可以直接在锁屏的情况下回复或进入应用。另外，如果在操作手机的过程中有电话进入，也不会进行全画面的切换，而是同样以通知的方式告知用户。 引入Material Design设计 扁平化的设计理念，新的视觉语言，在基本元素的处理上，几件了传统的印刷设计，字体版式、网格系统、空间、比例、调色、图像使用等这些基础的平面设计规范。 Project Volta电池续航改进计划 Project Volta计划增加了新工具可以让开发者能够更容易的找出为何自己的应用程序会对电量产生比较大的影响，同时确保在执行某些任务时将手机电量的影响降至最低。首先，Battery Historian可以列出手机电量消耗的详细情况，帮助开发者识别电量消耗的原因或者是哪个硬件或任务对电池寿命的影响比较大；而Job Scheduler API则可以让开发者更容易的选择合适的时机触发电量消耗比较高的任务，避免在低电量或未完成充电时更新应用程序。 而对于用户层面上，Android L 增加了Battery Saver模式，在低电量时系统会调整某些耗电设置，如降低屏幕亮度、限制自动更换背景等。 全新的”最近应用程序“ 除了界面风格设计的改变之外，新的最近应用界面还借鉴了Chrome浏览器的理念，采用单独的标签展示方式。而且，谷歌已经向开发者开放了API，所以第三方开发人员可以利用这个改进为特定的应用增加全新的功能。getAppTasks() 改进安全性 支持多种设备 可以在智能手机、平板电脑、笔记本电脑、智能电视、汽车、智能手表甚至是各种家用电子产品等设备上使用Android系统。 支持OpenGL ES3.1 媒体控件和 RemoteControlClient 支持Android NDK中的64位 只能显示绑定到服务，取消隐藏绑定服务 WebView API修改 自定义权限唯一性要求 TLS/SSL 默认配置变更 服务器不支持任何已启用的加密套件 应用对用于连接服务器的加密套件做出错误的假设 服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展 支持托管配置文件 Android 4.4 支持Android Beam 添加打印框架 存储访问框架 低功耗传感器 添加短信提供程序 添加全屏沉浸模式 Android 沉浸式状态栏的三种实现方式 兼容库SystemBarTint 添加透明系统 UI 样式 添加新的媒体功能 RenderScript Compute 持续性能提升 GPU 加速 Android NDK 中的 RenderScript 图形 GLES2.0 SurfaceFlinge 新的硬件合成器支持虚拟显示 支持新的连接类型 新的蓝牙配置文件 红外发射器 Wi-Fi TDLS 支持 无障碍功能 安全增强功能 内存使用率分析工具 Procstats Android 4.0,4.1,4.2,4.3 支持OpenGL ES 3.0 增强蓝牙连接 优化位置和传感器 添加转场动画 支持Daydream 人脸识别解锁 Photo Sphere 全景相片 Android API对照表Android Beta，发布于2007年11月5日，同时的软件开发套件(SDK)，发布于2007年11月12日。 11月5日被认为是Android的”生日”。 Android每个版本都有个API Level，对应着某个Android发布版本的名称。 Android版本名称Code name Android版本 版本发布时间 对应API (no code name) 1.0 2008年9月23日 API level 1 (no code name) 1.1 2009年2月9日 API level 2 Cupcake 纸杯蛋糕 1.5 2009年4月27日 API level 3,NDK 1 Donut 甜甜圈 1.6 2009年9月15日 API level 4,NDK 2 Eclair 泡芙 2 2009年10月26日 API level 5 Eclair 2.0.1 2009年12月3日 API level 6 Eclair 2.1 2010年1月12日 API level 7,NDK3 Froyo 冻酸奶 2.2.x 2010年5月20日 API level 8,NDK 4 Gingerbread 姜饼 2.3 – 2.3.2 2010年12月6日 API level 9,NDK5 Gingerbread 2.3.3 – 2.3.7 2011年2月9日 API level 10 Honeycomb 蜂巢 3.0 2011年2月22日 API level 11 Honeycomb 3.1 2011年5月10日 API level 12,NDK 6 Honeycomb 3.2.x 2011年7月15日 API level 13 Ice Cream Sandwich 4.0.1 – 4.0.2 2011年10月18日 API level 14,NDK 7 Ice Cream Sandwich 4.0.3 – 4.0.4 2011年12月16日 API level 15,NDK 8 Jelly Bean 果冻豆 4.1.x 2012年7月9日 API level 16 Jelly Bean 4.2.x 2012年11月13日 API level 17 Jelly Bean 4.3.x 2013年7月24日 API level 18 KitKat 奇巧 4.4.x 2013年10月31日 API level 19 KitKat 4.4W.x 2014年6月25日 API level 20 Lollipop(Android L) 棒棒糖 5.0 – 5.0.2 2014年11月12日 API level 21 Lollipop(Android L) 5.1 – 5.1.1 2015年3月9日 API level 22 Marshmallow(Android M) 6.0 – 6.0.1 2015年10月5日 API level 23 Nougat(Android N) 牛轧糖 7.0 2016年8月22日 API level 24 Nougat(Android N) 7.1.1 2016年10月 API level 25 Oreo(Android O) 奥利奥 8.0 2017年3月21日 API level 26 Oreo(Android O) Android Go 8.1 2017年12月6日 API level 27 Pistachio Ice Cream(Android P) 9 2018年8月6日 API level 28","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"feature","slug":"feature","permalink":"http://lichaoyu.com/tags/feature/"},{"name":"version","slug":"version","permalink":"http://lichaoyu.com/tags/version/"}]},{"title":"Android推送分析","slug":"2018-06-19_Android推送分析","date":"2018-06-19T03:23:16.000Z","updated":"2018-06-20T07:43:56.220Z","comments":true,"path":"2018/06/19/2018-06-19_Android推送分析/","link":"","permalink":"http://lichaoyu.com/2018/06/19/2018-06-19_Android推送分析/","excerpt":"","text":"一些基本概念阻塞指执行设备操作时，不能获得资源则挂起进程，被挂起的进程进入休眠，从调度器的进行队列中移走。 非阻塞指在不能获得资源的情况下，要么放弃，要么不停地查询，直到可以操作。 C/S通讯思路实现客户端和服务器端实时通讯，有两种思路： 定时去server查询数据，通常是通过HTTP协议来访问web服务器，称为Polling(轮询)； 移动端和服务器建立长连接，使用XMPP长连接，称为Push(推送)。 Push在Android平台上长连接的实现 既然我们知道我们移动端要和Internet进行通信，必须通过运营商的网关，所以，为了不让NAT映射表失效，我们需要定时向Internet发送数据，因为只是为了不然NAT映射表失效，所以只需发送长度为0的数据即可。注意这种定时发送的时间又叫心跳时间。 Timer:可以按照计划或者时间周期来执行相关的任务。但是Timer需要用WakeLock来让CPU保持唤醒状态，才能保证任务的执行，这样子会消耗大量流量；当CPU处于休眠的时候，就不能唤醒执行任务，所以应用于移动端明显是不合适。 AlarmManager：AlarmManager类是属于android系统封装好来管理RTC模块的管理类。这里就涉及到RTC模块，要更好地了解两者的区别，就要明白两者真正的区别。RTC（Real- Time Clock）实时闹钟在一个嵌入式系统中，通常采用RTC 来提供可靠的系统时间，包括时分秒和年月日等;而且要求在系统处于关机状态下它也能够正常工作（通常采用后备电池供电），它的外围也不需要太多的辅助电路，典型的就是只需要一个高精度的32.768KHz 晶体和电阻电容等。（如果对这方面感兴趣，可以自己查阅相关资料，这里就说个大概）好了，回来正题。所以，AlarmManager又称全局定时闹钟。这意味着，当我用使用AlarmManager来定时执行任务，CPU可以正常地休眠，只有在执行任务是，才唤醒CPU，这个过程是很短时间的。 实现全局定时功能： 1234//获得闹钟管理器 AlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);//设置任务执行计划 //从firstTime才开始执行，每隔5秒再执行am.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, firstTime, 5*1000, sender); 总结：在android客户端使用Push推送时，应该使用AlarmManager全局定时来实现心跳功能，使其真正实现长连接。 服务器端实现当有大量的手机终端需要与服务器维持长连接时，对服务器的设计会是一个很大的挑战。 假设一台服务器维护10万个长连接，当有1000万用户量时，需要有多达100台的服务器来维护这些用户的长连接，这里还不算用于做备份的服务器，这将会是一个巨大的成本问题。那就需要我们尽可能提高单台服务器接入用户的量，也就是业界已经讨论很久了的 C10K 问题。 这是他们怎么做的了，他们是非常巧妙的利用cpu中多核的原理，利用多核来唤起了相应核数个线程了，并且利用非阻塞的消息队列的机制，大大提高了服务器的吞吐量了，这样能够是一个服务器维持200个左右的长连接了，这样有效突破了业界一个瓶颈了。可见多核实现了android消息推送重要性。相应的思维导图如下： 实时通讯方式示例图 痛难点及解决方案做推送需要解决的最大三个问题：电量消耗，数据流量消耗，服务持久化。 电量消耗优化与数据流量消耗优化： 这两个问题其实可以合并成一个问题，因为请求服务器其实也是一个费电的事情。与维持一个长连接类似，要实现推送功能，不管是维持一个长连接或者是定时请求服务器都需要耗费网络数据流量，而只不过长连接是一个细水长流不断耗费，而轮询是一次一大断数据的耗费。这样就需要一种可行的策略去配置，让轮询按照我们想要的方式去执行。目前我采用的思路是当手机处于GPRS模式时降低轮询的频率，每5分钟请求一次服务器，当手机处于WiFi模式时每2分钟请求一次服务器，同时设置如果熄灭屏幕则停止推送请求，当屏幕熄灭20秒后杀死推送进程，这样不仅不需要考虑维护一个进程的消耗同时也节省了数据流量的使用。 服务持久化： 服务持久化就是进程常驻，说白了就是进程保活。要尽可能使我们的进程保持较高的优先级，不轻易被系统杀死。像QQ微信这种应用做的就非常好，不管使用第三方手机助手或者使用系统停止一个应用(不是设置里面的那种停止，是长按Home键的那种)，后台Service都不会被回收。 在Android的ActivityManager中有一个内部类RunningAppProcessInfo，用来记录当前系统中进程的状态，如下是其中一些值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Constant for &#123;@link #importance&#125;: This process is running the * foreground UI; that is, it is the thing currently at the top of the screen * that the user is interacting with. */public static final int IMPORTANCE_FOREGROUND = 100;/** * Constant for &#123;@link #importance&#125;: This process is running a foreground * service, for example to perform music playback even while the user is * not immediately in the app. This generally indicates that the process * is doing something the user actively cares about. */public static final int IMPORTANCE_FOREGROUND_SERVICE = 125;/** * Constant for &#123;@link #importance&#125;: This process is running the foreground * UI, but the device is asleep so it is not visible to the user. This means * the user is not really aware of the process, because they can not see or * interact with it, but it is quite important because it what they expect to * return to once unlocking the device. */public static final int IMPORTANCE_TOP_SLEEPING = 150;/** * Constant for &#123;@link #importance&#125;: This process is running something * that is actively visible to the user, though not in the immediate * foreground. This may be running a window that is behind the current * foreground (so paused and with its state saved, not interacting with * the user, but visible to them to some degree); it may also be running * other services under the system's control that it inconsiders important. */public static final int IMPORTANCE_VISIBLE = 200;/** * Constant for &#123;@link #importance&#125;: This process is not something the user * is directly aware of, but is otherwise perceptible to them to some degree. */public static final int IMPORTANCE_PERCEPTIBLE = 230;/** * Constant for &#123;@link #importance&#125;: This process is running an * application that can not save its state, and thus can't be killed * while in the background. * @hide */public static final int IMPORTANCE_CANT_SAVE_STATE= 270;/** * Constant for &#123;@link #importance&#125;: This process is contains services * that should remain running. These are background services apps have * started, not something the user is aware of, so they may be killed by * the system relatively freely (though it is generally desired that they * stay running as long as they want to). */public static final int IMPORTANCE_SERVICE = 300;/** * Constant for &#123;@link #importance&#125;: This process process contains * cached code that is expendable, not actively running any app components * we care about. */public static final int IMPORTANCE_CACHED = 400;/** * @deprecated Renamed to &#123;@link #IMPORTANCE_CACHED&#125;. */public static final int IMPORTANCE_BACKGROUND = IMPORTANCE_CACHED;/** * Constant for &#123;@link #importance&#125;: This process is empty of any * actively running code. * @deprecated This value is no longer reported, use &#123;@link #IMPORTANCE_CACHED&#125; instead. */@Deprecatedpublic static final int IMPORTANCE_EMPTY = 500;/** * Constant for &#123;@link #importance&#125;: This process does not exist. */public static final int IMPORTANCE_GONE = 1000; 一般数值大于RunningAppProcessInfo.IMPORTANCE_SERVICE的进程都长时间没用或者空进程了 一般数值大于RunningAppProcessInfo.IMPORTANCE_VISIBLE的进程都是非可见进程，也就是在后台运行着 第三方清理软件清理的一般是大于IMPORTANCE_VISIBLE的值，所以要想不被杀死就需要将自己的进程降低到IMPORTANCE_VISIBLE以下，也就是可见进程的程度。在每一个Service中有一个方法叫startForeground,也就是以可见进程的模式启动，这里是在SDK源码中的实现与注释，可以看到，它会在通知栏持续显示一个通知，但只需要将id传为0即可避免通知的显示。当然要取消这种可见进程等级的设置只需要调stopForgeround即可。 心跳包的作用网上很多文章介绍长连接的时候都说: 因为是长连接, 所以需要定期发送心跳包. 心跳包是用来通知服务器客户端当前状态. 明确一点, TCP长连接本质上不需要心跳包来维持, 大家可以试一试, 让两台电脑连上同一个wifi, 然后让其中一台做服务器, 另一台用一个普通的没有设置KeepAlive的Socket连上服务器, 只要两台电脑别断网, 路由器也别断电, DHCP正常续租, 就这么放着, 过几个小时再用其中一台电脑通过之前建立的TCP连接给另一台发消息, 另一台肯定能收到. 那为什么要有心跳包呢? 其实主要是为了防止上面提到的NAT超时, 既然一些NAT设备判断是否淘汰NAT映射的依据是一定时间没有数据, 那么客户端就主动发一个数据. 当然, 如果仅仅是为了防止NAT超时, 可以让服务器来发送心跳包给客户端, 不过这样做有个弊病就是, 万一连接断了, 服务器就再也联系不上客户端了. 所以心跳包必须由客户端发送, 客户端发现连接断了, 还可以尝试重连服务器. 所以心跳包的主要作用是防止NAT超时, 其次是探测连接是否断开. 链路断开, 没有写操作的TCP连接是感知不到的, 除非这个时候发送数据给服务器, 造成写超时, 否则TCP连接不会知道断开了. 主动kill掉一方的进程, 另一方会关闭TCP连接, 是系统代进程给服务器发的FIN. TCP连接就是这样, 只有明确的收到对方发来的关闭连接的消息(收到RST也会关闭, 大家都懂), 或者自己意识到发生了写超时, 否则它认为连接还存在. 心跳包的时间间隔既然心跳包的主要作用是防止NAT超时, 那么这个间隔就大有文章了. 发送心跳包势必要先唤醒设备, 然后才能发送, 如果唤醒设备过于频繁, 或者直接导致设备无法休眠, 会大量消耗电量, 而且移动网络下进行网络通信, 比在wifi下耗电得多. 所以这个心跳包的时间间隔应该尽量的长, 最理想的情况就是根本没有NAT超时, 比如刚才我说的两台在同一个wifi下的电脑, 完全不需要心跳包. 这也就是网上常说的长连接, 慢心跳. 现实是残酷的, 根据网上的一些说法, 中移动2/3G下, NAT超时时间为5分钟, 中国电信3G则大于28分钟, 理想的情况下, 客户端应当以略小于NAT超时时间的间隔来发送心跳包. wifi下, NAT超时时间都会比较长, 据说宽带的网关一般没有空闲释放机制, GCM有些时候在wifi下的心跳比在移动网络下的心跳要快, 可能是因为wifi下联网通信耗费的电量比移动网络下小. 关于如何让心跳间隔逼近NAT超时的间隔, 同时自动适应NAT超时间隔的变化, 可以参看Android微信智能心跳方案. 服务器如何处理心跳包如果客户端心跳间隔是固定的, 那么服务器在连接闲置超过这个时间还没收到心跳时, 可以认为对方掉线, 关闭连接. 如果客户端心跳会动态改变, 如上节提到的微信心跳方案, 应当设置一个最大值, 超过这个最大值才认为对方掉线. 还有一种情况就是服务器通过TCP连接主动给客户端发消息出现写超时, 可以直接认为对方掉线. 这个就需要具体业务具体分析了, 也许还有更优的策略, 这里就不写了. 心跳包和轮询的区别心跳包和轮询看起来类似, 都是客户端主动联系服务器, 但是区别很大. 轮询是为了获取数据, 而心跳是为了保活TCP连接. 轮询得越频繁, 获取数据就越及时, 心跳的频繁与否和数据是否及时没有直接关系 轮询比心跳能耗更高, 因为一次轮询需要经过TCP三次握手, 四次挥手, 单次心跳不需要建立和拆除TCP连接. TCP唤醒Android这部分内容我只知道结论, 不知道具体的知识 大家有没有想过, 手机的短信功能和微信的功能差不多, 为什么微信会比短信耗电这么多? 当然不是因为短信一条0.1元. 手机短信是通过什么获取推送的呢? 下面这段出处不明的话也许可以给大家启示 首先Android手机有两个处理器, 一个叫Application Processor(AP), 一个叫Baseband Processor(BP). AP是ARM架构的处理器，用于运行Android系统; BP用于运行实时操作系统(RTOS), 通讯协议栈运行于BP的RTOS之上. 非通话时间, BP的能耗基本上在5mA左右，而AP只要处于非休眠状态, 能耗至少在50mA以上, 执行图形运算时会更高. 另外LCD工作时功耗在100mA左右, WIFI也在100mA左右. 一般手机待机时, AP, LCD, WIFI均进入休眠状态, 这时Android中应用程序的代码也会停止执行. Android为了确保应用程序中关键代码的正确执行, 提供了Wake Lock的API, 使得应用程序有权限通过代码阻止AP进入休眠状态. 但如果不领会Android设计者的意图而滥用Wake Lock API, 为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态, 就会成为待机电池杀手. 完全没必要担心AP休眠会导致收不到消息推送. 通讯协议栈运行于BP，一旦收到数据包, BP会将AP唤醒, 唤醒的时间足够AP执行代码完成对收到的数据包的处理过程. 其它的如Connectivity事件触发时AP同样会被唤醒. 那么唯一的问题就是程序如何执行向服务器发送心跳包的逻辑. 你显然不能靠AP来做心跳计时. Android提供的Alarm Manager就是来解决这个问题的. Alarm应该是BP计时(或其它某个带石英钟的芯片，不太确定，但绝对不是AP), 触发时唤醒AP执行程序代码. 那么Wake Lock API有啥用呢? 比如心跳包从请求到应答, 比如断线重连重新登陆这些关键逻辑的执行过程, 就需要Wake Lock来保护. 而一旦一个关键逻辑执行成功, 就应该立即释放掉Wake Lock了. 两次心跳请求间隔5到10分钟, 基本不会怎么耗电. 除非网络不稳定. 频繁断线重连, 那种情况办法不多. 上面所说的通信协议, 我猜应该是无线资源控制协议(Radio Resource Control), RRC应该工作在OSI参考模型中的第三层网络层, 而TCP, UDP工作在第四层传输层, 上文说的BP, 应该就是手机中的基带。 移动网络下, 每一个TCP连接底层都应该是有RRC连接, 而RRC连接会唤醒基带, 基带会唤醒CPU处理TCP数据, 这是我个人的理解. 至于wifi下如何工作, 我暂时没有找到资料. 上面说了这么多, 其实意思就是TCP数据包能唤醒手机. 至于UDP, 我不确定. 而推送中最重要的部分就是让手机尽量休眠, 只有在服务器需要它处理数据时才唤醒它, 这正好符合我们的要求.","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"Push","slug":"Push","permalink":"http://lichaoyu.com/tags/Push/"},{"name":"Polling","slug":"Polling","permalink":"http://lichaoyu.com/tags/Polling/"}]},{"title":"Java反射机制总结","slug":"2018-06-13_Java反射机制总结","date":"2018-06-13T05:04:46.000Z","updated":"2018-06-20T06:28:22.340Z","comments":true,"path":"2018/06/13/2018-06-13_Java反射机制总结/","link":"","permalink":"http://lichaoyu.com/2018/06/13/2018-06-13_Java反射机制总结/","excerpt":"","text":"Java反射机制总结反射的概念在Java中程序可以访问、检测和修改它自身状态或行为的一种能力。简单来说，就是只要给定类的名字，就可以知道这个类的所有属性和方法，这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。 反射的作用 在运行时判断任意一个对象所属的类； 在运行时获取类的对象； 在运行时访问Java对象的属性，方法以及构造方法等。 反射的优缺点优点： 可以实现动态创建对象和编译，最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。 缺点： （1）对性能有影响。 （2）使用反射相对来说不安全。 （3）破坏了类的封装性，可以通过反射获取这个类的私有方法和属性。 使用注意事项性能第一：反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用反射。 安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行。 内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用——代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 使用示例 关于Class Class是一个类，一个描述类的类（也就是描述类本身），封装了描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性 对象照镜子后（反射）可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。 对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 Class 对象只能由系统建立对象 一个类在 JVM 中只会有一个Class实例 获取Class有三种方法12345678910111213Class clazz = null;// 1.直接通过类名.class的方式得到clazz = Test.class;// 2.通过对象的getClass()方法获取Object obj = new Test();clazz = obj.getClass();// 3.通过全类名获取，用的比较多，但可能抛出ClassNotFoundException异常try &#123; clazz = Class.forName(\"com.lcy.demo.reflection.Test\"); System.out.println(\"通过全类名获取:\" + clazz);&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 利用newInstance创建对象：调用的类必须有无参构造器123456Class clazz = Class.forName(\"com.java.reflection.Person\"); //使用Class类的newInstance()方法创建类的一个对象 //实际调用的类的那个 无参数的构造器（这就是为什么写的类的时候，要写一个无参数的构造器，就是给反射用的） //一般的，一个类若声明了带参数的构造器，也要声明一个无参数的构造器 Object obj = clazz.newInstance(); System.out.println(obj); 输出 Person{name=’null’, age=0} Java类加载器 类加载器示例图 12345678910111213141516// 获取一个系统的类加载器ClassLoader classLoader = ClassLoader.getSystemClassLoader();System.out.println(\"系统类加载器：\" + classLoader);// 获取系统类加载器的父类加载器（扩展加载器）classLoader = classLoader.getParent();System.out.println(\"扩展加载器：\" + classLoader);// 获取扩展加载器的父类加载器// 输出为NULL，无法被Java程序直接引用classLoader = classLoader.getParent();System.out.println(\"启动类加载器\" + classLoader);// 测试当前类由哪个加载器加载，结果就是系统的类加载器classLoader = Class.forName(\"com.lcy.demo.reflection.Test\").getClassLoader();System.out.println(\"当前类由哪个类加载：\" + classLoader);// 测试JDK提供的Object类由哪个类加载器加载classLoader = Class.forName(\"java.lang.Object\").getClassLoader();System.out.println(\"Object类由哪个类加载：\" + classLoader); 系统的类加载器–&gt;sun.misc.LauncherAppClassLoader@43be2d65 扩展类加载器–&gt;sun.misc.LauncherExtClassLoader@7a9664a1 启动类加载器–&gt;null 当前类由哪个类加载器进行加载–&gt;sun.misc.Launcher$AppClassLoader@43be2d65 JDK提供的Object类由哪个类加载器加载–&gt;null getResourceAsStream()：类加载器的一个主要方法，获取类路径下的文件对应的输入流。 12345678910InputStream in = classLoader.getResourceAsStream(\"com/lcy/demo/reflection/test.properties\"); try &#123; Properties properties = new Properties(); properties.load(in); System.out.println(properties.getProperty(\"driver\")); System.out.println(new String(properties.getProperty(\"user\").getBytes(\"ISO-8859-1\"), \"UTF-8\")); System.out.println(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Method：类中方法获取clazz对应类中除私有方法外的所有方法 1Method[] methods = clazz.getMethods(); 获取clazz当前类中声明的所有方法 1Method[] declaredMethods = clazz.getDeclaredMethods(); 获取指定方法 1Method method = clazz.getDeclaredMethod(\"setName\", String.class); Invoke()12345Method method = clazz.getDeclaredMethod(\"privateMethod\");// 通过反射执行private方法 method.setAccessible(true);Object obj = clazz.newInstance();method.invoke(obj, \"lcy\"); Field字段123456789101112//1.1 获取Field的数组,私有字段也能获取 Field[] fields = clazz.getDeclaredFields(); //1.2 获取指定名字的Field（如果是私有的，见下面的4) Field field = clazz.getDeclaredField(\"name\"); Person person = new Person(\"ABC\", 12); //2、获取指定对象的Field的值 Object val = field.get(person); //3、设置指定对象的Field的值 field.set(person, \"changwen2\"); //4、若该字段是私有的，需要调用setAccessible(true)方法 Field field2 = clazz.getDeclaredField(\"age\"); field2.setAccessible(true); 构造器(Constructor)1234//1.获取Constructor对象 Constructor&lt;Person&gt; constructor = clazz.getConstructor(String.class, Integer.class); //2.调用构造器的newInstance()方法创建对象 Object obj= constructor.newInstance(\"changwen\", 11);","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://lichaoyu.com/tags/Java/"},{"name":"Reflection","slug":"Reflection","permalink":"http://lichaoyu.com/tags/Reflection/"}]},{"title":"Android8.0通知适配（NotificationChannel）","slug":"android8-0-notification","date":"2018-05-17T05:10:37.000Z","updated":"2018-06-16T03:59:05.551Z","comments":true,"path":"2018/05/17/android8-0-notification/","link":"","permalink":"http://lichaoyu.com/2018/05/17/android8-0-notification/","excerpt":"","text":"Android8.0 NotificationCannelNotificationCannel是Android8.0的新特性，如果App的targetSDKVersion&gt;=26，没有设置channel通知渠道的话，就会导致通知无法展示。 Android O 引入了 通知渠道（Notification Channels），以提供统一的系统来帮助用户管理通知，如果是针对 android O 为目标平台时，必须实现一个或者多个通知渠道，以向用户显示通知。比如聊天软件，为每个聊天组设置一个通知渠道，指定特定声音、灯光等配置。 国内app基本都集成了第三方推送SDK，目前使用的两个推送平台都还没进行适配，所以还需要等第三方出新版本并集成，如果我们app内部也有自己弹出通知逻辑，最好和他们保持一致，毕竟app内设置多个通知渠道不方便维护。 报错内容： Failed to post notification on channel “null” Target Api is 26 原因： 目前NotificationCompat.Builder(context)方法已deprecated，在Android 8.0系统推荐使用NotificationCompat.Builder(context, channelId)方法，为通知设置相应渠道。 解决方案： 下面是一个通知管理类，包含Android8.0通知处理逻辑，仅供参考。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class NotificationUtils extends ContextWrapper &#123; private NotificationManager manager; public static final int NOTIFICATION_ID = 1; public static final String CHANNEL_ID = \"channel_1\"; public static final String CHANNEL_NAME = \"channel_name_1\"; public NotificationUtils(Context context) &#123; super(context); &#125; /** * 创建通知渠道 **/ @RequiresApi(api = Build.VERSION_CODES.O) public void createNotificationChannel() &#123; NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH); channel.enableLights(true); //是否在桌面icon右上角展示小红点 channel.setLightColor(Color.GREEN); //小红点颜色 channel.setShowBadge(true); //是否在久按桌面图标时显示此渠道的通知 getManager().createNotificationChannel(channel); &#125; private NotificationManager getManager() &#123; if (manager == null) &#123; manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; return manager; &#125; /** * 初始化NotificationCompat.Builder * 适配android 8.0 */ private NotificationCompat.Builder getNotification(String title, String content, NotificationItem item) &#123; NotificationCompat.Builder builder; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; createNotificationChannel(); //设置渠道，channelId要与创建时的channelId对应 builder = new NotificationCompat.Builder(getApplicationContext(), CHANNEL_ID); &#125; else &#123; builder = new NotificationCompat.Builder(getApplicationContext()); &#125; builder.setContentTitle(title) .setContentText(content) .setSmallIcon(android.R.drawable.stat_notify_more) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.logo)) .setWhen(System.currentTimeMillis()) .setPriority(NotificationCompat.PRIORITY_HIGH) .setDefaults(NotificationCompat.DEFAULT_SOUND | NotificationCompat .DEFAULT_VIBRATE) // 设置默认铃声与震动 .setFullScreenIntent(initPendingIntent(item), true) //悬挂式通知 .setContentIntent(initPendingIntent(item)) .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) // 锁屏通知，显示通知全部内容 .setAutoCancel(true); return builder; &#125; /** * 点击通知后跳转意图，开发者可自行定义item类，根据不同的type处理各业务逻辑，如相应跳转等。 */ private PendingIntent initPendingIntent(NotificationItem item) &#123; Intent intent = new Intent(getApplicationContext(), MainActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); return pi; &#125; /** * 显示通知 */ public void sendNotification(String title, String content, NotificationItem item) &#123; Notification notification = getNotification(title, content, item).build(); getManager().notify(NOTIFICATION_ID, notification); &#125; /** * 取消通知 */ public void cancelNotification() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; getManager().deleteNotificationChannel(CHANNEL_ID); &#125; getManager().cancel(NOTIFICATION_ID); &#125;&#125; 管理类具体使用： 12NotificationUtils notificationUtils = new NotificationUtils(this);notificationUtils.sendNotification(\"通知标题\", \"通知内容\", entity); Android Notification 四种方式部分参考 https://blog.csdn.net/yxncl/article/details/72801230 实现通知的一般步骤 获取NotificationManager实例来管理通知； 实例Notification对象； 管理点击事件Intent，PendingIntent； 发送通知(notificationManager.notify(id, notification)) 使用NotificationCompat.Builder是为了解决Notification.Builder的兼容问题，可最低支持API Level 4。 普通通知获取NotificationManager实例对象： 1NotificationManager manager = (NotificationManager) context.getSystemService(NOTIFICATION_SERVICE); 通过NotificationCompat.Builder创建Notification对象，可以通过builder相应方法进行设置： 1234567891011Notification notication = new NotificationCompat.Builder(this) .setContentTitle(title) .setContentText(content) .setContentIntent(pi) //设置点击逻辑 .setOngoing(true) //true则用户不能手动清除 setAutoCancel(true)点击之后消失 .setPriority(NotificationCompat.PRIORITY_HIGH) // 设置通知优先级 .setSmallIcon(R.mipmap.ic_launcher_round) // 设置状态栏小图标 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) // 设置下拉通知栏中的icon .setWhen(System.currentTimeMillis()) // 设置通知显示时间为当前时间戳，立即显示 .setDefaults(NotificationCompat.DEFAULT_SOUND | NotificationCompat.DEFAULT_VIBRATE) // 设置默认声音和震动效果 .build(); 设置点击通知后逻辑，自行根据相应业务： 123Intent intent = new Intent(this, NotificationActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); 显示通知，参数一的id指定通知的唯一id： 1manager.notify(NOTIFICATION_ID, notification); 取消通知： 1manager.cancel(NOTIFICATION_ID); 悬挂式通知1builder.setFullScreenIntent(pi, true) setPriority()方法共有5个等级： PRIORITY_MIN - 最低级别（-2）； PRIORITY_LOW - 较低级别（-1）； PRIORITY_DEFAULT - 默认级别（0）； PRIORITY_HIGH - 较高级别（1）； PRIORITY_MAX - 最高级别（2）； 当发出此类型的通知时，通知会以悬挂的方法显示在屏幕上。 折叠通知折叠式同时需要借助 RemoteViews 来实现 123456789101112131415161718192021222324Notification builder = new NotificationCompat.Builder(Context); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.sina.com&quot;)); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); // 未下拉的样式 R.layout.collapsed RemoteViews collapsed = new RemoteViews(getPackageName(), R.layout.collapsed); collapsed.setTextViewText(R.id.collapsed_text, &quot;关闭状态&quot;); //下拉后的样式R.layout.show RemoteViews show = new RemoteViews(getPackageName(), R.layout.show); Notification notify = builder.setAutoCancel(true) .setSmallIcon(R.mipmap.ic_launcher_round) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi) .setContentText(&quot;新浪微博&quot;) .setCustomContentView(collapsed)//下拉前 .setCustomBigContentView(show)//下拉后 .build(); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.notify(0, notify); 锁屏通知1builder.setVisibility(NotificationCompat.VISIBILITY_PUBLIC) setVisibility() 方法共有三个选值： VISIBILITY_PRIVATE : 显示基本信息，如通知的图标，但隐藏通知的全部内容； VISIBILITY_PUBLIC : 显示通知的全部内容； VISIBILITY_SECRET : 不显示任何内容，包括图标。 不足之处欢迎指出，码农不易，携手共进^~^","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"Android8.0","slug":"Android8-0","permalink":"http://lichaoyu.com/tags/Android8-0/"},{"name":"Notification","slug":"Notification","permalink":"http://lichaoyu.com/tags/Notification/"}]},{"title":"ES6的十大特性","slug":"ES6的十大特性","date":"2018-05-13T15:59:23.000Z","updated":"2018-07-16T16:13:48.798Z","comments":true,"path":"2018/05/13/ES6的十大特性/","link":"","permalink":"http://lichaoyu.com/2018/05/13/ES6的十大特性/","excerpt":"","text":"你好ES6","categories":[{"name":"FE","slug":"FE","permalink":"http://lichaoyu.com/categories/FE/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://lichaoyu.com/tags/IT/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://lichaoyu.com/tags/JavaScript/"}]},{"title":"Android Studio","slug":"android1","date":"2018-05-07T09:05:06.000Z","updated":"2018-06-16T03:58:52.496Z","comments":true,"path":"2018/05/07/android1/","link":"","permalink":"http://lichaoyu.com/2018/05/07/android1/","excerpt":"","text":"Welcome to my own zone, first of all, let me introduce something to you, then you can communicate with me for android development problems, Let’s start. 第一步这是第一步123public static void main(String[] args)&#123; println(\"Hello World!\");&#125; 第二步这是第二步 123456789101112131415public static AlertDialog showDefaultDialog(Activity activity, @StringRes int title, @StringRes int content, boolean cancelable, @StringRes int confirm, @StringRes int cancel, DialogInterface.OnClickListener confirmListener, DialogInterface.OnClickListener cancelListener) &#123; return new AlertDialog.Builder(activity) .setTitle(title) .setMessage(content) .setCancelable(cancelable) .setNegativeButton(confirm, confirmListener) .setPositiveButton(cancel, cancelListener) .setOnDismissListener(new DialogInterface.OnDismissListener() &#123; @Override public void onDismiss(DialogInterface dialog) &#123; dialog.dismiss(); &#125; &#125;) .show(); &#125; 第三步这是第三步 123456789101112131415161718192021222324addCompositeDisposable( getBaseModel().logout(), new RxObserver&lt;Object&gt;() &#123; /** * 数据流传递的结果 * * @param result */ @Override public void response(Object result) &#123; getBaseView().onLogoutSuccess(App.mAppContext.getString(R.string.log_out)); &#125; /** * 数据流过程中出现错误 * * @param message 不为空 */ @Override public void error(String message) &#123; getBaseView().onLogoutFail(message); &#125; &#125; );","categories":[{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/categories/Android/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://lichaoyu.com/tags/Java/"},{"name":"IT","slug":"IT","permalink":"http://lichaoyu.com/tags/IT/"},{"name":"Android","slug":"Android","permalink":"http://lichaoyu.com/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-05T12:19:50.665Z","updated":"2018-05-07T05:35:01.707Z","comments":true,"path":"2018/05/05/hello-world/","link":"","permalink":"http://lichaoyu.com/2018/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}