<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android推送分析</title>
      <link href="/2018/06/19/2018-06-19_Android%E6%8E%A8%E9%80%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/19/2018-06-19_Android%E6%8E%A8%E9%80%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p><strong>阻塞</strong>指执行设备操作时，不能获得资源则挂起进程，被挂起的进程进入休眠，从调度器的进行队列中移走。          <strong>非阻塞</strong>指在不能获得资源的情况下，要么放弃，要么不停地查询，直到可以操作。</p><h3 id="C-S通讯思路"><a href="#C-S通讯思路" class="headerlink" title="C/S通讯思路"></a>C/S通讯思路</h3><p>实现客户端和服务器端实时通讯，有两种思路：</p><ol><li>定时去server查询数据，通常是通过HTTP协议来访问web服务器，称为Polling(轮询)；</li><li>移动端和服务器建立长连接，使用XMPP长连接，称为Push(推送)。</li></ol><p><strong>Push在Android平台上长连接的实现</strong><br>　　既然我们知道我们移动端要和Internet进行通信，必须通过运营商的网关，所以，为了不让NAT映射表失效，我们需要定时向Internet发送数据，因为只是为了不然NAT映射表失效，所以只需发送长度为0的数据即可。注意这种定时发送的时间又叫心跳时间。</p><p>　　<strong>Timer</strong>:可以按照计划或者时间周期来执行相关的任务。但是Timer需要用WakeLock来让CPU保持唤醒状态，才能保证任务的执行，这样子会消耗大量流量；当CPU处于休眠的时候，就不能唤醒执行任务，所以应用于移动端明显是不合适。<br>　　<strong>AlarmManager</strong>：AlarmManager类是属于android系统封装好来管理RTC模块的管理类。这里就涉及到RTC模块，要更好地了解两者的区别，就要明白两者真正的区别。<br>RTC（Real- Time Clock）实时闹钟在一个嵌入式系统中，通常采用RTC 来提供可靠的系统时间，包括时分秒和年月日等;而且要求在系统处于关机状态下它也能够正常工作（通常采用后备电池供电），它的外围也不需要太多的辅助电路，典型的就是只需要一个高精度的32.768KHz 晶体和电阻电容等。（如果对这方面感兴趣，可以自己查阅相关资料，这里就说个大概）<br>好了，回来正题。所以，AlarmManager又称全局定时闹钟。这意味着，当我用使用AlarmManager来定时执行任务，CPU可以正常地休眠，只有在执行任务是，才唤醒CPU，这个过程是很短时间的。</p><p>实现全局定时功能： 　　　　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得闹钟管理器 </span></span><br><span class="line">AlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);<span class="comment">//设置任务执行计划 </span></span><br><span class="line"><span class="comment">//从firstTime才开始执行，每隔5秒再执行</span></span><br><span class="line">am.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, firstTime, <span class="number">5</span>*<span class="number">1000</span>, sender);</span><br></pre></td></tr></table></figure><p><strong>总结：在android客户端使用Push推送时，应该使用AlarmManager全局定时来实现心跳功能，使其真正实现长连接。心跳包的主要作用是防止NAT超时, 其次是探测连接是否断开。</strong></p><h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><p>当有大量的手机终端需要与服务器维持长连接时，对服务器的设计会是一个很大的挑战。 　　</p><p>假设一台服务器维护10万个长连接，当有1000万用户量时，需要有多达100台的服务器来维护这些用户的长连接，这里还不算用于做备份的服务器，这将会是一个巨大的成本问题。那就需要我们尽可能提高单台服务器接入用户的量，也就是业界已经讨论很久了的 C10K 问题。       </p><p>这是他们怎么做的了，他们是非常巧妙的利用cpu中多核的原理，利用多核来唤起了相应核数个线程了，并且利用非阻塞的消息队列的机制，大大提高了服务器的吞吐量了，这样能够是一个服务器维持200个左右的长连接了，这样有效突破了业界一个瓶颈了。可见多核实现了android消息推送重要性。相应的思维导图如下：</p><figure class="image-box">                <img src="/2018/06/19/2018-06-19_Android推送分析/push.jpg" alt="实时通讯方式示例图" title="" class="">                <p>实时通讯方式示例图</p>            </figure><h3 id="痛难点及解决方案"><a href="#痛难点及解决方案" class="headerlink" title="痛难点及解决方案"></a>痛难点及解决方案</h3><p>做推送需要解决的最大三个问题：<strong>电量消耗，数据流量消耗，服务持久化。</strong></p><p><strong>电量消耗优化与数据流量消耗优化：</strong></p><p>这两个问题其实可以合并成一个问题，因为请求服务器其实也是一个费电的事情。与维持一个长连接类似，要实现推送功能，不管是维持一个长连接或者是定时请求服务器都需要耗费网络数据流量，而只不过长连接是一个细水长流不断耗费，而轮询是一次一大断数据的耗费。这样就需要一种可行的策略去配置，让轮询按照我们想要的方式去执行。目前我采用的思路是当手机处于GPRS模式时降低轮询的频率，每5分钟请求一次服务器，当手机处于WiFi模式时每2分钟请求一次服务器，同时设置如果熄灭屏幕则停止推送请求，当屏幕熄灭20秒后杀死推送进程，这样不仅不需要考虑维护一个进程的消耗同时也节省了数据流量的使用。</p><p><strong>服务持久化：</strong></p><p>服务持久化就是进程常驻，说白了就是进程保活。要尽可能使我们的进程保持较高的优先级，不轻易被系统杀死。像QQ微信这种应用做的就非常好，不管使用第三方手机助手或者使用系统停止一个应用(不是设置里面的那种停止，是长按Home键的那种)，后台Service都不会被回收。</p><p>在Android的ActivityManager中有一个内部类RunningAppProcessInfo，用来记录当前系统中进程的状态，如下是其中一些值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process is running the</span></span><br><span class="line"><span class="comment"> * foreground UI; that is, it is the thing currently at the top of the screen</span></span><br><span class="line"><span class="comment"> * that the user is interacting with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_FOREGROUND = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process is running a foreground</span></span><br><span class="line"><span class="comment"> * service, for example to perform music playback even while the user is</span></span><br><span class="line"><span class="comment"> * not immediately in the app.  This generally indicates that the process</span></span><br><span class="line"><span class="comment"> * is doing something the user actively cares about.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_FOREGROUND_SERVICE = <span class="number">125</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process is running the foreground</span></span><br><span class="line"><span class="comment"> * UI, but the device is asleep so it is not visible to the user.  This means</span></span><br><span class="line"><span class="comment"> * the user is not really aware of the process, because they can not see or</span></span><br><span class="line"><span class="comment"> * interact with it, but it is quite important because it what they expect to</span></span><br><span class="line"><span class="comment"> * return to once unlocking the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_TOP_SLEEPING = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process is running something</span></span><br><span class="line"><span class="comment"> * that is actively visible to the user, though not in the immediate</span></span><br><span class="line"><span class="comment"> * foreground.  This may be running a window that is behind the current</span></span><br><span class="line"><span class="comment"> * foreground (so paused and with its state saved, not interacting with</span></span><br><span class="line"><span class="comment"> * the user, but visible to them to some degree); it may also be running</span></span><br><span class="line"><span class="comment"> * other services under the system's control that it inconsiders important.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_VISIBLE = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process is not something the user</span></span><br><span class="line"><span class="comment"> * is directly aware of, but is otherwise perceptible to them to some degree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_PERCEPTIBLE = <span class="number">230</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process is running an</span></span><br><span class="line"><span class="comment"> * application that can not save its state, and thus can't be killed</span></span><br><span class="line"><span class="comment"> * while in the background.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_CANT_SAVE_STATE= <span class="number">270</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process is contains services</span></span><br><span class="line"><span class="comment"> * that should remain running.  These are background services apps have</span></span><br><span class="line"><span class="comment"> * started, not something the user is aware of, so they may be killed by</span></span><br><span class="line"><span class="comment"> * the system relatively freely (though it is generally desired that they</span></span><br><span class="line"><span class="comment"> * stay running as long as they want to).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_SERVICE = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process process contains</span></span><br><span class="line"><span class="comment"> * cached code that is expendable, not actively running any app components</span></span><br><span class="line"><span class="comment"> * we care about.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_CACHED = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> Renamed to &#123;<span class="doctag">@link</span> #IMPORTANCE_CACHED&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_BACKGROUND = IMPORTANCE_CACHED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process is empty of any</span></span><br><span class="line"><span class="comment"> * actively running code.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> This value is no longer reported, use &#123;<span class="doctag">@link</span> #IMPORTANCE_CACHED&#125; instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_EMPTY = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant for &#123;<span class="doctag">@link</span> #importance&#125;: This process does not exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMPORTANCE_GONE = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>一般数值大于RunningAppProcessInfo.IMPORTANCE_SERVICE的进程都长时间没用或者空进程了</p><p>一般数值大于RunningAppProcessInfo.IMPORTANCE_VISIBLE的进程都是非可见进程，也就是在后台运行着</p><p>第三方清理软件清理的一般是大于IMPORTANCE_VISIBLE的值，所以要想不被杀死就需要将自己的进程降低到IMPORTANCE_VISIBLE以下，也就是可见进程的程度。在每一个Service中有一个方法叫startForeground,也就是以可见进程的模式启动，这里是在SDK源码中的实现与注释，可以看到，它会在通知栏持续显示一个通知，但只需要将id传为0即可避免通知的显示。当然要取消这种可见进程等级的设置只需要调stopForgeround即可。</p><h3 id="心跳包的时间间隔"><a href="#心跳包的时间间隔" class="headerlink" title="心跳包的时间间隔"></a>心跳包的时间间隔</h3><p>既然心跳包的主要作用是防止NAT超时, 那么这个间隔就大有文章了.</p><p>发送心跳包势必要先唤醒设备, 然后才能发送, 如果唤醒设备过于频繁, 或者直接导致设备无法休眠, 会大量消耗电量, 而且移动网络下进行网络通信, 比在wifi下耗电得多. 所以这个心跳包的时间间隔应该尽量的长, 最理想的情况就是根本没有NAT超时, 比如刚才我说的两台在同一个wifi下的电脑, 完全不需要心跳包. 这也就是网上常说的<em>长连接, 慢心跳</em>.</p><p>现实是残酷的, 根据网上的一些说法, 中移动2/3G下, NAT超时时间为5分钟, 中国电信3G则大于28分钟, 理想的情况下, 客户端应当以略小于NAT超时时间的间隔来发送心跳包.</p><p>wifi下, NAT超时时间都会比较长, 据说宽带的网关一般没有空闲释放机制, GCM有些时候在wifi下的心跳比在移动网络下的心跳要快, 可能是因为wifi下联网通信耗费的电量比移动网络下小.</p><p>关于如何让心跳间隔逼近NAT超时的间隔, 同时自动适应NAT超时间隔的变化, 可以参看<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207243549&amp;idx=1&amp;sn=4ebe4beb8123f1b5ab58810ac8bc5994&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">Android微信智能心跳方案</a>.</p><h3 id="服务器如何处理心跳包"><a href="#服务器如何处理心跳包" class="headerlink" title="服务器如何处理心跳包"></a>服务器如何处理心跳包</h3><p>如果客户端心跳间隔是固定的, 那么服务器在连接闲置超过这个时间还没收到心跳时, 可以认为对方掉线, 关闭连接. 如果客户端心跳会动态改变, 如上节提到的微信心跳方案, 应当设置一个最大值, 超过这个最大值才认为对方掉线. 还有一种情况就是服务器通过TCP连接主动给客户端发消息出现写超时, 可以直接认为对方掉线.</p><p>这个就需要具体业务具体分析了, 也许还有更优的策略, 这里就不写了.</p><h3 id="心跳包和轮询的区别"><a href="#心跳包和轮询的区别" class="headerlink" title="心跳包和轮询的区别"></a>心跳包和轮询的区别</h3><p>心跳包和轮询看起来类似, 都是客户端主动联系服务器, 但是区别很大.</p><ul><li>轮询是为了获取数据, 而心跳是为了保活TCP连接.</li><li>轮询得越频繁, 获取数据就越及时, 心跳的频繁与否和数据是否及时没有直接关系</li><li>轮询比心跳能耗更高, 因为一次轮询需要经过TCP三次握手, 四次挥手, 单次心跳不需要建立和拆除TCP连接.</li></ul><h3 id="TCP唤醒Android"><a href="#TCP唤醒Android" class="headerlink" title="TCP唤醒Android"></a>TCP唤醒Android</h3><p><em>这部分内容我只知道结论, 不知道具体的知识</em> 大家有没有想过, 手机的短信功能和微信的功能差不多, 为什么微信会比短信耗电这么多? 当然不是因为短信一条0.1元. 手机短信是通过什么获取推送的呢? 下面这段出处不明的话也许可以给大家启示</p><blockquote><p>首先Android手机有两个处理器, 一个叫Application Processor(AP), 一个叫Baseband Processor(BP). AP是ARM架构的处理器，用于运行Android系统; BP用于运行实时操作系统(RTOS), 通讯协议栈运行于BP的RTOS之上. 非通话时间, BP的能耗基本上在5mA左右，而AP只要处于非休眠状态, 能耗至少在50mA以上, 执行图形运算时会更高. 另外LCD工作时功耗在100mA左右, WIFI也在100mA左右. 一般手机待机时, AP, LCD, WIFI均进入休眠状态, 这时Android中应用程序的代码也会停止执行.</p><p>Android为了确保应用程序中关键代码的正确执行, 提供了Wake Lock的API, 使得应用程序有权限通过代码阻止AP进入休眠状态. 但如果不领会Android设计者的意图而滥用Wake Lock API, 为了自身程序在后台的正常工作而长时间阻止AP进入休眠状态, 就会成为待机电池杀手.</p><p>完全没必要担心AP休眠会导致收不到消息推送. 通讯协议栈运行于BP，一旦收到数据包, BP会将AP唤醒, 唤醒的时间足够AP执行代码完成对收到的数据包的处理过程. 其它的如Connectivity事件触发时AP同样会被唤醒. 那么唯一的问题就是程序如何执行向服务器发送心跳包的逻辑. 你显然不能靠AP来做心跳计时. Android提供的Alarm Manager就是来解决这个问题的. Alarm应该是BP计时(或其它某个带石英钟的芯片，不太确定，但绝对不是AP), 触发时唤醒AP执行程序代码. 那么Wake Lock API有啥用呢? 比如心跳包从请求到应答, 比如断线重连重新登陆这些关键逻辑的执行过程, 就需要Wake Lock来保护. 而一旦一个关键逻辑执行成功, 就应该立即释放掉Wake Lock了. 两次心跳请求间隔5到10分钟, 基本不会怎么耗电. 除非网络不稳定. 频繁断线重连, 那种情况办法不多.</p></blockquote><p>上面所说的通信协议, 我猜应该是无线资源控制协议(Radio Resource Control), RRC应该工作在OSI参考模型中的第三层网络层, 而TCP, UDP工作在第四层传输层, 上文说的BP, 应该就是手机中的基带。</p><p>移动网络下, 每一个TCP连接底层都应该是有RRC连接, 而RRC连接会唤醒基带, 基带会唤醒CPU处理TCP数据, 这是我个人的理解.</p><p>至于wifi下如何工作, 我暂时没有找到资料.</p><p>上面说了这么多, 其实意思就是TCP数据包能唤醒手机. 至于UDP, 我不确定.</p><p>而<strong>推送中最重要的部分就是让手机尽量休眠, 只有在服务器需要它处理数据时才唤醒它, 这正好符合我们的要求</strong>.</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Push </tag>
            
            <tag> Polling </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射机制总结</title>
      <link href="/2018/06/13/2018-06-13_Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/13/2018-06-13_Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="Java反射机制总结"><a href="#Java反射机制总结" class="headerlink" title="Java反射机制总结"></a>Java反射机制总结</h2><h3 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h3><p>在Java中程序可以访问、检测和修改它自身状态或行为的一种能力。简单来说，就是只要给定类的名字，就可以知道这个类的所有属性和方法，这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p><h3 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h3><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时获取类的对象；</li><li>在运行时访问Java对象的属性，方法以及构造方法等。</li></ol><h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><p>优点：</p><p>可以实现动态创建对象和编译，最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。</p><p>缺点：</p><p>（1）对性能有影响。</p><p>（2）使用反射相对来说不安全。</p><p>（3）破坏了类的封装性，可以通过反射获取这个类的私有方法和属性。</p><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p><strong>性能第一：</strong>反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用反射。</p><p><strong>安全限制：</strong>使用反射技术要求程序必须在一个没有安全限制的环境中运行。</p><p><strong>内部暴露：</strong>由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用——代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><hr><h4 id="关于Class"><a href="#关于Class" class="headerlink" title="关于Class"></a>关于Class</h4><blockquote><ol><li>Class是一个类，一个描述类的类（也就是描述类本身），封装了描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性    </li><li>对象照镜子后（反射）可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。     </li><li>对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。    </li><li>Class 对象只能由系统建立对象     </li><li>一个类在 JVM 中只会有一个Class实例</li></ol></blockquote><h4 id="获取Class有三种方法"><a href="#获取Class有三种方法" class="headerlink" title="获取Class有三种方法"></a>获取Class有三种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 1.直接通过类名.class的方式得到</span></span><br><span class="line">clazz = Test.class;</span><br><span class="line"><span class="comment">// 2.通过对象的getClass()方法获取</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Test();</span><br><span class="line">clazz = obj.getClass();</span><br><span class="line"><span class="comment">// 3.通过全类名获取，用的比较多，但可能抛出ClassNotFoundException异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    clazz = Class.forName(<span class="string">"com.lcy.demo.reflection.Test"</span>);</span><br><span class="line">    System.out.println(<span class="string">"通过全类名获取:"</span> + clazz);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用newInstance创建对象：调用的类必须有无参构造器"><a href="#利用newInstance创建对象：调用的类必须有无参构造器" class="headerlink" title="利用newInstance创建对象：调用的类必须有无参构造器"></a>利用newInstance创建对象：调用的类必须有无参构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.java.reflection.Person"</span>);  </span><br><span class="line"><span class="comment">//使用Class类的newInstance()方法创建类的一个对象  </span></span><br><span class="line"><span class="comment">//实际调用的类的那个 无参数的构造器（这就是为什么写的类的时候，要写一个无参数的构造器，就是给反射用的）  </span></span><br><span class="line"><span class="comment">//一般的，一个类若声明了带参数的构造器，也要声明一个无参数的构造器  </span></span><br><span class="line">Object obj = clazz.newInstance();  </span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><blockquote><p>输出 Person{name=’null’, age=0}</p></blockquote><h4 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h4><figure class="image-box">                <img src="/2018/06/13/2018-06-13_Java反射机制总结/classloader.png" alt="类加载器示例图" title="" class="">                <p>类加载器示例图</p>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个系统的类加载器</span></span><br><span class="line">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(<span class="string">"系统类加载器："</span> + classLoader);</span><br><span class="line"><span class="comment">// 获取系统类加载器的父类加载器（扩展加载器）</span></span><br><span class="line">classLoader = classLoader.getParent();</span><br><span class="line">System.out.println(<span class="string">"扩展加载器："</span> + classLoader);</span><br><span class="line"><span class="comment">// 获取扩展加载器的父类加载器</span></span><br><span class="line"><span class="comment">// 输出为NULL，无法被Java程序直接引用</span></span><br><span class="line">classLoader = classLoader.getParent();</span><br><span class="line">System.out.println(<span class="string">"启动类加载器"</span> + classLoader);</span><br><span class="line"><span class="comment">// 测试当前类由哪个加载器加载，结果就是系统的类加载器</span></span><br><span class="line">classLoader = Class.forName(<span class="string">"com.lcy.demo.reflection.Test"</span>).getClassLoader();</span><br><span class="line">System.out.println(<span class="string">"当前类由哪个类加载："</span> + classLoader);</span><br><span class="line"><span class="comment">// 测试JDK提供的Object类由哪个类加载器加载</span></span><br><span class="line">classLoader = Class.forName(<span class="string">"java.lang.Object"</span>).getClassLoader();</span><br><span class="line">System.out.println(<span class="string">"Object类由哪个类加载："</span> + classLoader);</span><br></pre></td></tr></table></figure><blockquote><p>系统的类加载器–&gt;sun.misc.LauncherAppClassLoader@43be2d65 </p><p>扩展类加载器–&gt;sun.misc.LauncherExtClassLoader@7a9664a1 </p><p>启动类加载器–&gt;null </p><p>当前类由哪个类加载器进行加载–&gt;sun.misc.Launcher$AppClassLoader@43be2d65 </p><p>JDK提供的Object类由哪个类加载器加载–&gt;null</p></blockquote><p><strong>getResourceAsStream()：</strong>类加载器的一个主要方法，获取类路径下的文件对应的输入流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = classLoader.getResourceAsStream(<span class="string">"com/lcy/demo/reflection/test.properties"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            System.out.println(properties.getProperty(<span class="string">"driver"</span>));</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(properties.getProperty(<span class="string">"user"</span>).getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="Method：类中方法"><a href="#Method：类中方法" class="headerlink" title="Method：类中方法"></a>Method：类中方法</h4><p>获取clazz对应类中除私有方法外的所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = clazz.getMethods();</span><br></pre></td></tr></table></figure><p>获取clazz当前类中声明的所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] declaredMethods = clazz.getDeclaredMethods();</span><br></pre></td></tr></table></figure><p>获取指定方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">"setName"</span>, String.class);</span><br></pre></td></tr></table></figure><h4 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke()"></a>Invoke()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">"privateMethod"</span>);</span><br><span class="line"><span class="comment">// 通过反射执行private方法 </span></span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">method.invoke(obj, <span class="string">"lcy"</span>);</span><br></pre></td></tr></table></figure><h4 id="Field字段"><a href="#Field字段" class="headerlink" title="Field字段"></a>Field字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1 获取Field的数组,私有字段也能获取  </span></span><br><span class="line">Field[] fields = clazz.getDeclaredFields();  </span><br><span class="line"><span class="comment">//1.2 获取指定名字的Field（如果是私有的，见下面的4)  </span></span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">"name"</span>);  </span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"ABC"</span>, <span class="number">12</span>);  </span><br><span class="line"><span class="comment">//2、获取指定对象的Field的值  </span></span><br><span class="line">Object val = field.get(person);    </span><br><span class="line"><span class="comment">//3、设置指定对象的Field的值  </span></span><br><span class="line">field.set(person, <span class="string">"changwen2"</span>);  </span><br><span class="line"><span class="comment">//4、若该字段是私有的，需要调用setAccessible(true)方法  </span></span><br><span class="line">Field field2 = clazz.getDeclaredField(<span class="string">"age"</span>);  </span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="构造器-Constructor"><a href="#构造器-Constructor" class="headerlink" title="构造器(Constructor)"></a>构造器(Constructor)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取Constructor对象 </span></span><br><span class="line">Constructor&lt;Person&gt; constructor = clazz.getConstructor(String.class, Integer.class);  </span><br><span class="line"><span class="comment">//2.调用构造器的newInstance()方法创建对象  </span></span><br><span class="line">Object obj= constructor.newInstance(<span class="string">"changwen"</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Reflection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android8.0通知适配（NotificationChannel）</title>
      <link href="/2018/05/17/android8-0-notification/"/>
      <url>/2018/05/17/android8-0-notification/</url>
      <content type="html"><![CDATA[<h2 id="Android8-0-NotificationCannel"><a href="#Android8-0-NotificationCannel" class="headerlink" title="Android8.0 NotificationCannel"></a>Android8.0 NotificationCannel</h2><p>NotificationCannel是Android8.0的新特性，如果App的targetSDKVersion&gt;=26，没有设置channel通知渠道的话，就会导致通知无法展示。</p><blockquote><p>Android O 引入了 通知渠道（Notification Channels），以提供统一的系统来帮助用户管理通知，如果是针对 android O 为目标平台时，必须实现一个或者多个通知渠道，以向用户显示通知。比如聊天软件，为每个聊天组设置一个通知渠道，指定特定声音、灯光等配置。</p></blockquote><blockquote><p>国内app基本都集成了第三方推送SDK，目前使用的两个推送平台都还没进行适配，所以还需要等第三方出新版本并集成，如果我们app内部也有自己弹出通知逻辑，最好和他们保持一致，毕竟app内设置多个通知渠道不方便维护。</p></blockquote><p>报错内容：</p><p><strong>Failed to post notification on channel “null” Target Api is 26</strong></p><p>原因：</p><p>目前<strong>NotificationCompat.Builder(context)</strong>方法已deprecated，在Android 8.0系统推荐使用<strong>NotificationCompat.Builder(context, channelId)</strong>方法，为通知设置相应渠道。</p><p>解决方案：</p><p>下面是一个通知管理类，包含Android8.0通知处理逻辑，仅供参考。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationUtils</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NotificationManager manager;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOTIFICATION_ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHANNEL_ID = <span class="string">"channel_1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHANNEL_NAME = <span class="string">"channel_name_1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotificationUtils</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建通知渠道</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.O)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNotificationChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NotificationChannel channel = <span class="keyword">new</span> NotificationChannel(CHANNEL_ID, CHANNEL_NAME,</span><br><span class="line">                NotificationManager.IMPORTANCE_HIGH);</span><br><span class="line">        channel.enableLights(<span class="keyword">true</span>); <span class="comment">//是否在桌面icon右上角展示小红点</span></span><br><span class="line">        channel.setLightColor(Color.GREEN); <span class="comment">//小红点颜色</span></span><br><span class="line">        channel.setShowBadge(<span class="keyword">true</span>); <span class="comment">//是否在久按桌面图标时显示此渠道的通知</span></span><br><span class="line">        getManager().createNotificationChannel(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> NotificationManager <span class="title">getManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (manager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化NotificationCompat.Builder</span></span><br><span class="line"><span class="comment">     * 适配android 8.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> NotificationCompat.<span class="function">Builder <span class="title">getNotification</span><span class="params">(String title, String content,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      NotificationItem item)</span> </span>&#123;</span><br><span class="line">        NotificationCompat.Builder builder;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            createNotificationChannel();</span><br><span class="line">            <span class="comment">//设置渠道，channelId要与创建时的channelId对应 </span></span><br><span class="line">            builder = <span class="keyword">new</span> NotificationCompat.Builder(getApplicationContext(), CHANNEL_ID);    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder = <span class="keyword">new</span> NotificationCompat.Builder(getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        builder.setContentTitle(title)</span><br><span class="line">                .setContentText(content)</span><br><span class="line">                .setSmallIcon(android.R.drawable.stat_notify_more)</span><br><span class="line">                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.logo))</span><br><span class="line">                .setWhen(System.currentTimeMillis())</span><br><span class="line">                .setPriority(NotificationCompat.PRIORITY_HIGH)</span><br><span class="line">                .setDefaults(NotificationCompat.DEFAULT_SOUND | NotificationCompat</span><br><span class="line">                        .DEFAULT_VIBRATE) <span class="comment">// 设置默认铃声与震动</span></span><br><span class="line">                .setFullScreenIntent(initPendingIntent(item), <span class="keyword">true</span>)  <span class="comment">//悬挂式通知</span></span><br><span class="line">                .setContentIntent(initPendingIntent(item))</span><br><span class="line">                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) <span class="comment">// 锁屏通知，显示通知全部内容</span></span><br><span class="line">                .setAutoCancel(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击通知后跳转意图，开发者可自行定义item类，根据不同的type处理各业务逻辑，如相应跳转等。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PendingIntent <span class="title">initPendingIntent</span><span class="params">(NotificationItem item)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(getApplicationContext(), MainActivity.class);</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, intent, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotification</span><span class="params">(String title, String content, NotificationItem item)</span> </span>&#123;</span><br><span class="line">        Notification notification = getNotification(title, content, item).build();</span><br><span class="line">        getManager().notify(NOTIFICATION_ID, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            getManager().deleteNotificationChannel(CHANNEL_ID);</span><br><span class="line">        &#125;</span><br><span class="line">        getManager().cancel(NOTIFICATION_ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理类具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotificationUtils notificationUtils = <span class="keyword">new</span> NotificationUtils(<span class="keyword">this</span>);</span><br><span class="line">notificationUtils.sendNotification(<span class="string">"通知标题"</span>, <span class="string">"通知内容"</span>, entity);</span><br></pre></td></tr></table></figure><h2 id="Android-Notification-四种方式"><a href="#Android-Notification-四种方式" class="headerlink" title="Android Notification 四种方式"></a>Android Notification 四种方式</h2><p>部分参考 <a href="https://blog.csdn.net/yxncl/article/details/72801230" target="_blank" rel="noopener">https://blog.csdn.net/yxncl/article/details/72801230</a></p><blockquote><p><strong>实现通知的一般步骤</strong></p><ol><li>获取<strong>NotificationManager</strong>实例来管理通知；</li><li>实例<strong>Notification</strong>对象；</li><li>管理点击事件<strong>Intent</strong>，<strong>PendingIntent</strong>；</li><li>发送通知(notificationManager.notify(id, notification))</li></ol></blockquote><p>使用NotificationCompat.Builder是为了解决Notification.Builder的兼容问题，可最低支持API Level 4。</p><h3 id="普通通知"><a href="#普通通知" class="headerlink" title="普通通知"></a>普通通知</h3><p>获取<strong>NotificationManager</strong>实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager manager = (NotificationManager) context.getSystemService(NOTIFICATION_SERVICE);</span><br></pre></td></tr></table></figure><p>通过<strong>NotificationCompat.Builder</strong>创建<strong>Notification</strong>对象，可以通过builder相应方法进行设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Notification notication = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .setContentTitle(title)</span><br><span class="line">        .setContentText(content)</span><br><span class="line">        .setContentIntent(pi) <span class="comment">//设置点击逻辑</span></span><br><span class="line">        .setOngoing(<span class="keyword">true</span>) <span class="comment">//true则用户不能手动清除 setAutoCancel(true)点击之后消失</span></span><br><span class="line">        .setPriority(NotificationCompat.PRIORITY_HIGH) <span class="comment">// 设置通知优先级</span></span><br><span class="line">        .setSmallIcon(R.mipmap.ic_launcher_round) <span class="comment">// 设置状态栏小图标</span></span><br><span class="line">        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) <span class="comment">// 设置下拉通知栏中的icon</span></span><br><span class="line">        .setWhen(System.currentTimeMillis()) <span class="comment">// 设置通知显示时间为当前时间戳，立即显示</span></span><br><span class="line">        .setDefaults(NotificationCompat.DEFAULT_SOUND | NotificationCompat.DEFAULT_VIBRATE) <span class="comment">// 设置默认声音和震动效果</span></span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>设置点击通知后逻辑，自行根据相应业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, NotificationActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, intent, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>显示通知，参数一的id指定通知的唯一id：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.notify(NOTIFICATION_ID, notification);</span><br></pre></td></tr></table></figure><p>取消通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.cancel(NOTIFICATION_ID);</span><br></pre></td></tr></table></figure><h3 id="悬挂式通知"><a href="#悬挂式通知" class="headerlink" title="悬挂式通知"></a>悬挂式通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.setFullScreenIntent(pi, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>setPriority()方法共有5个等级：</strong></p><p>PRIORITY_MIN - 最低级别（-2）； </p><p>PRIORITY_LOW - 较低级别（-1）； </p><p>PRIORITY_DEFAULT - 默认级别（0）； </p><p>PRIORITY_HIGH - 较高级别（1）；  </p><p>PRIORITY_MAX - 最高级别（2）；  </p></blockquote><p>当发出此类型的通知时，通知会以悬挂的方法显示在屏幕上。</p><h3 id="折叠通知"><a href="#折叠通知" class="headerlink" title="折叠通知"></a>折叠通知</h3><p>折叠式同时需要借助 <strong>RemoteViews</strong> 来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Notification builder = new NotificationCompat.Builder(Context);</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.sina.com&quot;));</span><br><span class="line"></span><br><span class="line">    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);</span><br><span class="line"></span><br><span class="line">    // 未下拉的样式 R.layout.collapsed</span><br><span class="line">    RemoteViews collapsed = new RemoteViews(getPackageName(), R.layout.collapsed);</span><br><span class="line">    collapsed.setTextViewText(R.id.collapsed_text, &quot;关闭状态&quot;);</span><br><span class="line"></span><br><span class="line">    //下拉后的样式R.layout.show</span><br><span class="line">    RemoteViews show = new RemoteViews(getPackageName(), R.layout.show);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Notification notify = builder.setAutoCancel(true)</span><br><span class="line">            .setSmallIcon(R.mipmap.ic_launcher_round)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))</span><br><span class="line">            .setContentIntent(pi)</span><br><span class="line">            .setContentText(&quot;新浪微博&quot;)</span><br><span class="line">            .setCustomContentView(collapsed)//下拉前</span><br><span class="line">            .setCustomBigContentView(show)//下拉后</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">    manager.notify(0, notify);</span><br></pre></td></tr></table></figure><h3 id="锁屏通知"><a href="#锁屏通知" class="headerlink" title="锁屏通知"></a>锁屏通知</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.setVisibility(NotificationCompat.VISIBILITY_PUBLIC)</span><br></pre></td></tr></table></figure><blockquote><p><strong>setVisibility()</strong> 方法共有三个选值： </p><p>VISIBILITY_PRIVATE : 显示基本信息，如通知的图标，但隐藏通知的全部内容；  </p><p>VISIBILITY_PUBLIC : 显示通知的全部内容；  </p><p>VISIBILITY_SECRET : 不显示任何内容，包括图标。</p></blockquote><p><strong>不足之处欢迎指出，码农不易，携手共进^~^</strong></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android8.0 </tag>
            
            <tag> Notification </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6的十大特性</title>
      <link href="/2018/05/13/ES6%E7%9A%84%E5%8D%81%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2018/05/13/ES6%E7%9A%84%E5%8D%81%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>你好ES6</p>]]></content>
      
      <categories>
          
          <category> FE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Studio</title>
      <link href="/2018/05/07/android1/"/>
      <url>/2018/05/07/android1/</url>
      <content type="html"><![CDATA[<p>Welcome to my own zone, first of all, let me introduce something to you, then you can communicate with me for android development problems, Let’s start.</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>这是第一步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>这是第二步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AlertDialog <span class="title">showDefaultDialog</span><span class="params">(Activity activity, @StringRes <span class="keyword">int</span> title, @StringRes <span class="keyword">int</span> content, <span class="keyword">boolean</span> cancelable, @StringRes <span class="keyword">int</span> confirm, @StringRes <span class="keyword">int</span> cancel, DialogInterface.OnClickListener confirmListener, DialogInterface.OnClickListener cancelListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AlertDialog.Builder(activity)</span><br><span class="line">            .setTitle(title)</span><br><span class="line">            .setMessage(content)</span><br><span class="line">            .setCancelable(cancelable)</span><br><span class="line">            .setNegativeButton(confirm, confirmListener)</span><br><span class="line">            .setPositiveButton(cancel, cancelListener)</span><br><span class="line">            .setOnDismissListener(<span class="keyword">new</span> DialogInterface.OnDismissListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDismiss</span><span class="params">(DialogInterface dialog)</span> </span>&#123;</span><br><span class="line">                    dialog.dismiss();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>这是第三步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">addCompositeDisposable(</span><br><span class="line">            getBaseModel().logout(),</span><br><span class="line">            <span class="keyword">new</span> RxObserver&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 数据流传递的结果</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">                    getBaseView().onLogoutSuccess(App.mAppContext.getString(R.string.log_out));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 数据流过程中出现错误</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> message 不为空</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                    getBaseView().onLogoutFail(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
            <tag> Java </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/05/hello-world/"/>
      <url>/2018/05/05/hello-world/</url>
      <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=455543886&auto=1&height=66"></iframe><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
